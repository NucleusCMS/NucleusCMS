<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja-JP" xml:lang="ja-JP">
<head>
	<!-- $Id: plugins.html,v 1.7 2006-07-12 07:11:46 kimitake Exp $ -->
	<!-- $NucleusJP: plugins.html,v 1.6.2.1 2005/09/09 07:34:26 kimitake Exp $ -->
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Nucleus - プラグイン API</title>
	<link rel="stylesheet" type="text/css" href="styles/manual.css" />
	<style type="text/css">
		/* refence parameters (greenish) */
		.ref {
			background-color: #afa;	
			color: #000;
		}
		
		/* object parameters */
		.obj {
			color: #00f;
		}
		.obj:after {
			content: " (object)";
		}
		
		/* read-only parameters (non-ref; reddish) */
		.ro {
			background-color: #faa;
			color: #000;
		}
	</style>
</head>
<body>

<p class="heading">&nbsp;</p>
<div class="heading">
プラグイン API
<i>2005年7月27日</i>
</div>

<div class="note-trans"><strong>訳者注：</strong> 
	<ul>
		<li>このドキュメントの原文は以下のURLにあります。<br />
		 <a href="http://nucleuscms.org/documentation/devdocs/plugins.html">http://nucleuscms.org/documentation/devdocs/plugins.html</a></li>
	    <li>誤訳にお気づきの方は<a href="http://japan.nucleuscms.org/bb/viewforum.php?f=7">こちら</a>へご連絡いただけると助かります。</li>
	</ul>
</div>

<div class="note"><strong>注：</strong> 
	<ul>
		<li>このドキュメントは基本的なプラグインの書き方についての情報を提供しています。さらに質問がある方は <a href="http://forum.nucleuscms.org/viewforum.php?f=10">Plugin
	  Development Forum</a> （<a href="http://japan.nucleuscms.org/bb/viewforum.php?f=5">日本語フォーラム</a>）をご覧ください。</li>
		<li>Nucleusバージョン1.5以降に導入されたメソッドとイベントには、導入時のバージョン情報を付記しています。それらの機能を利用するときは、<code>getMinNucleusVersion</code> を適切に設定するのを忘れないでください。</li>
	</ul>
</div>

<h1>はじめに</h1>

<p>
<a href="./index.html">開発者向けドキュメントの目次へ戻る</a>
</p>

<p>
このドキュメントはNucleusプラグインの作り方についての解説です。 
</p>

<h1><a name="toc"></a><a name="top"></a>目次</h1>

<ul>
	<li><a href="#introduction">イントロダクション</a></li>
	<li><a href="#firstplug">はじめてプラグインを書いてみる</a></li>
	<li><a href="#nucleusplugin"><code>NucleusPlugin</code> クラスの概要</a></li>
	<li><a href="#skinvars"><code>&lt;%plugin(...)%&gt;</code> スキン変数</a></li>
	<li><a href="#templatevars"><code>&lt;%plugin(...)%&gt;</code> テンプレート変数</a></li>	
	<li><a href="#actions"><code>action.php</code> を使ったアクション</a></li>
	<li><a href="#events">イベントとイベント登録の仕方</a></li>
	<li><a href="#options">オプションを保存する</a></li>
	<li><a href="#tables">データベース・テーブル</a></li>
	<li><a href="#admin">プラグイン管理エリアの提供</a></li>
	<li><a href="#help">ヘルプページの提供</a></li>
	<li><a href="#dependency">プラグイン依存チェック</a></li>
<!--	<li><a href="#parser">Using the <code>PARSER</code> class</a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>-->
</ul>

<h1>イントロダクション <a name="introduction" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleusプラグインによって、誰もがNucleusの提供する機能を、Nucleus内部のPHPコードを変更することなく拡張することができます。プラグインはあるメソッドを実装したシンプルなPHPスクリプトで、Nucleusユーザー同士で簡単に交換することができます。インストールは簡単で、プラグインディレクトリにファイルをアップし、Nucleusにそれを認識させるだけです。
</p>

<p>
プラグインの利点は以下のとおりです。</p>

<ul>
	<li>実装について詳しくしらなくてもNucleusフレームワークに簡単に機能を追加できる</li>
	<li>必要なプラグインだけをインストールでき、ページ生成にかかる時間を節約できる</li>
</ul>

<p>
すべてのプラグインファイルは <code>config.php</code> に記述されたディレクトリに置く必要があります。一般的に、それは <code>/your/path/nucleus/plugins/</code>  になるでしょう。プラグインファイル名は <code>NP<i>_name</i>.php</code> という形式を用いることにより認識されます。プラグインによっては、追加ファイルを格納する同名のサブディレクトリや、管理エリアを必要とします。</p>

<div class="note">
<b>注：</b> プラグイン名は大文字・小文字を識別しますので、<code>Np_</code> や <code>np_</code> ではなく、<code>NP_</code> で始まることに気をつけてください。またプラグインがサブディレクトリを使用する場合は、サブディレクトリの名称は<em>すべて小文字にします</em>。</div>




<h1>はじめてプラグインを書いてみる<a name="firstplug" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
では、シンプルなプラグインを書いてみましょう。基本的にプラグインは、あらかじめ定義された <code>NucleusPlugin</code> クラスを継承したPHPクラスです。以下は<code>HelloWorld</code>プラグインの例です。</p>

<pre class="example"><code>&lt;?

class NP_HelloWorld extends NucleusPlugin
{

	// プラグインの名前
	function getName()
	{
		return 'Hello World'; 
	}
	
	// プラグインの作者
	function getAuthor()
	{ 
		return 'Wouter Demuynck'; 
	}
	
	// プラグインのサイトURL
	// mailto:foo@bar.com の形式も可
	function getURL() 
	{
		return '../../index.html'; 
	}
	
	// プラグインのバージョン
	function getVersion()
	{
		return '1.0'; 
	}
	
	// インストール済みのプラグインリストに表示される説明文
	function getDescription()
	{ 
		return 'Just a sample plugin.';
	}

	function doSkinVar($skinType)
	{
		echo 'Hello World!';
	}

	function supportsFeature ($what)
	{
		switch ($what)
		{
			case 'SqlTablePrefix':
				return 1;
			default:
				return 0;
		}
	}
	  
}
?&gt;</pre>

<ol>
	<li>
		このコードをコピーし、 <code>NP_HelloWorld.php</code> と名づけて保存し、プラグインディレクトリに置きます。<em>最後の <code>?&gt;</code> の後や、最初の <code>&lt;?</code> の前にスペースがないことを確認しましょう</em>。ところでNP は &quot;Nucleus Plugin&quot; って意味ですよ :-) 念のため。
	</li>
	<li>Nucleusの管理画面を開き、<em>Nucleusの管理＞プラグインの管理</em>にいきます。</li>
	<li><em>HelloWorld</em> プラグインがインストール可能な状態になっているはずですので、インストールします。すべてがうまくいけば、インストール済みプラグインリストに追加されます。</li>
	<li>あなたのスキンの１つを編集し、実際のページに表示する箇所に次の文を挿入します。
	  <pre class="example"><code>&lt;%HelloWorld%&gt;</code></pre>
	注意：カッコ内の名称 (<code>HelloWorld</code>) は大文字小文字を識別します！</li>
	<li>さて、編集したスキンから生成されるページを見てみましょう。プラグイン変数を追加した場所に &quot;Hello
  World&quot; と見えますね？</li>
</ol>

<p>ここまではそれほど難しくなかったと思います。さらに読み進めて理解してください。</p>


<h1>NucleusPlugin クラスの概要 <a name="nucleusplugin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>すべてのプラグインは、<code>NucleusPlugin</code> というPHPクラスを継承しなければなりません。難しそうに聞こえても心配ご無用、大丈夫です。このPHPクラスの継承によって、プラグインに必要なメソッドだけを実装でき、いくつかの補助ファンクションにアクセスでき、つまりはあなたの人生はよりラクになります。</p>

<p>下記は <code>NucleusPlugin</code> が提供する、再実装可能なメソッドの概要です。このクラス自身のソースコードを見たければ、<code>nucleus/libs/PLUGIN.php</code>にあります。</p>

<table summary="An overview of the redefinable methods in the class NucleusPlugin">
	<caption>
	<code>NucleusPlugin</code> クラスの概要（再定義可能なメソッド）
	</caption>
	<tr>
		<th>メソッド名</th><th>説明</th>
	</tr>
	<tr>
		<td><code>getName()</code></td>
		<td>プラグイン名を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>		
	</tr>
	<tr>
		<td><code>getAuthor()</code></td>
		<td>プラグインの作者名を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>		
	</tr>
	<tr>
		<td><code>getURL()</code></td>
		<td>プラグインをダウンロード可能な、またはプラグインの追加情報のあるサイトのURLを返します。そのようなサイトがない場合は作者のメールアドレスへの mailto:リンクが適切です。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>		
	</tr>
	<tr>
		<td><code>getDescription()</code></td>
		<td>プラグインに関する説明文（長文）を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返します。</td>		
	</tr>
	<tr>
		<td><code>getVersion()</code></td>
		<td>プラグインの現在のバージョンを返します。デフォルトは <code>0.0</code> を返します。</td>		
	</tr>
	<tr>
		<td><code>getMinNucleusVersion()</code></td>
		<td>(v2.0b) 最低限必要なNucleusのバージョンを返します。デフォルトは <code>155</code> (v1.55)を返します。後に導入されたプラグイン関連機能を利用している場合は、このファンクションを実装するようお願いします（例： v2.0 => 200）。ただし、Nucleus v1.55 はこのファンクションを使用しないため、新機能を利用したプラグインが（対応する前のシステムに）インストールされる可能性が残っています。</td>
	</tr>
	<tr>
		<td><code>getMinNucleusPatchLevel()</code></td>
		<td>(v3.1) 最低限必要なNucleusのバージョン(<code>getMinNucleusVersion</code>)での、最低限必要なパッチレベルを返します。デフォルトは <code>0</code> を返します。このファンクションは主に新しいプラグインの機能がNucleusの最新版のパッチによって可能になる場合に用いられます。</td>
	</tr>
	<tr>
		<td><code>init()</code></td>
		<td>プラグインを初期化します。このメソッドはプラグインオブジェクトが生成された直後に呼び出され、<code>plugid</code>属性がセットされます。デフォルトではこのメソッドは何もしません。</td>
	</tr>
	<tr>
		<td><code>doSkinVar($skinType)</code></td>
		<td><code>&lt;%plugin(...)%&gt;</code> スキン変数によってプラグインが呼び出されたときにこのメソッドが呼ばれます。<code>$skinType</code> パラメータはプラグインが呼ばれた場所のスキンタイプに該当します（<code>item</code>,
      <code>archive</code>, ...）。パラメータが一つしかないことに混乱しないでください。複数パラメータを渡すことも<strong>可能</strong>です。<a href="#skinvars"><code>doSkinVar</code> メソッドの実装に関する詳細情報はこちら</a>。デフォルトではこのメソッドはなにも出力しません。</td>		
	</tr>
	<tr>
		<td><code>doTemplateVar(&amp;$item)</code></td>
		<td>基本的に <code>doSkinVar</code> と同じですが、今度は<em>テンプレート</em>内（<code>item
		    header/body/footer</code> と <code>dateheader/footer</code>）での<code>&lt;%plugin(...)%&gt;</code> 変数からの呼び出しになります。デフォルトではこのメソッドはテンプレートをスキンタイプとみなして
      <code>doSkinVar</code> メソッドに処理を渡します。<a href="#templatevars"><code>doTemplateVar</code> メソッドの実装に関する詳細情報はこちら</a></td>		
	</tr>
	<tr>
		<td><code>doTemplateCommentsVar(&amp;$item, &amp;$comment)</code></td>
		<td>(v2.0b) 基本的に <code>doSkinVar</code> と同じですが、今度は<em>テンプレート</em>内（コメント部分）での<code>&lt;%plugin(...)%&gt;</code> 変数からの呼び出しになります。デフォルトではこのメソッドはテンプレートをスキンタイプとみなして
      <code>doSkinVar</code> メソッドに処理を渡します。<a href="#templatevars"><code>doTemplateCommentsVar</code> 
      メソッドの実装に関する詳細情報はこちら</a></td>		
	</tr>	
	<tr>
		<td><code>doAction($type)</code></td>
		<td>プラグインがユーザーインタラクションを求めたとき、 <code>action.php</code>を介してこのメソッドがそれを与えます。.
		  これはNucleus自身が新しいコメントや投票を処理するのに使用するスクリプトです。正しいパラメータを用いることで、プラグインからの
		  <code>doAction</code> メソッドを呼び出せます。<code>$type</code> はオプションのメッセージタイプに該当します。<code>doAction</code> メソッド内で、リクエストからの追加の変数にアクセスできます。デフォルトではこのメソッドがエラーメッセージをトリガーすると<code>'No
	  Such Action'</code>という文字列を返します。<a href="#actions"><code>doAction</code> に関する詳細情報はこちら</a></td>		
	</tr>
	<tr>
		<td><code>install()</code></td>
		<td>このメソッドはプラグインがインストールされた際に呼ばれます。データベース・テーブルの生成やプラグインオプションの生成などの初期化作業を行うことができます。デフォルトではこのメソッドは何もしません。</td>
	</tr>
	<tr>
		<td><code>unInstall()</code></td>
		<td>プラグインがアンインストールされた際に呼ばれます。この時点でデータベースに作られたプラグイン情報を消去すると良いです。デフォルトではこのメソッドは何もしません。</td>
	</tr>
	<tr>
		<td><code>getEventList()</code></td>
		<td>プラグインはイベント登録が可能です。イベントはNucleusが何かアクションを起こすたびに生成されます。たとえば、<code>AddItem</code> イベントは、このイベントを登録しているすべてのプラグインを呼び出します。呼び出されるメソッドは <code>event_AddItem($params)</code>になります。 <code>$params</code> パラメータは、例えば <code>AddItem</code>	  の <code>itemid</code> のような、情報フィールドを複数持つ連想配列です。デフォルトではどのイベントにも登録されていないことを示す空の配列を返します。<a href="#events">イベントに関する詳細情報
	  はこちら</a></td>		
	</tr>
	<tr>
		<td><code>getTableList()</code></td>
		<td>このメソッドはプラグインが生成したデータベース・テーブルの配列を返します。これはNucleusが提供するバックアップ機能で利用されるので、プラグインテーブルをバックアップに含めることができます。デフォルトでは空の配列を返します。</td>
	</tr>
	<tr>
		<td><code>hasAdminArea()</code></td>
		<td>プラグインが独自の管理エリアをもつ場合 1 を、そうでない場合 0 を返します。デフォルトでは <code>0</code> を返します。</td>
	</tr>
	<tr>
		<td><code>getPluginDep()</code></td>
		<td>(v3.2) プラグイン名の配列を返します。Nucleusはこれらのプラグインが前もってインストールされてない場合、プラグインのインストールを拒否します。デフォルトでは空の配列が返されます。<a href="#dependency">プラグイン依存に関する詳細情報はこちら</a></td>
	</tr>
</table>

<p>実装可能なメソッドの次は、<code>NucleusPlugin</code> クラスが提供する、再実装<strong>すべきでない</strong>幾つかの特殊メソッドです。これらはプラグイン内で、<code>$this-&gt;functionName()</code>シンタックスを利用して呼び出します。</p>

<table summary="An overview of the auxiliary methods in the class NucleusPlugin. You should NOT redefine these">
	<caption>
	<code>NucleusPlugin</code> クラスの概要（再定義不可能なメソッド）
	</caption>
	<tr>
		<th>メソッド名</th>
		<th>説明</th>
	</tr>
	<tr>
		<td>
			<code>createOption(...)</code>
			<br /><code>createBlogOption(...)</code>(v2.2)
			<br /><code>createCategoryOption(...)</code>(v2.2)
			<br /><code>createMemberOption(...)</code>(v2.2)
			<br /><code>createItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">新しいオプションを生成します。</a></td>		
	</tr>
	<tr>
		<td>
			<code>deleteOption(...)</code>
			<br /><code>deleteBlogOption(...)</code>(v2.2)
			<br /><code>deleteCategoryOption(...)</code>(v2.2)
			<br /><code>deleteMemberOption(...)</code>(v2.2)
			<br /><code>deleteItemOption(...)</code>(v3.2)
	   	</td>
		<td><a href="#options" title="More info on options">オプションを削除します。</a></td>		
	</tr>
	<tr>
		<td>
			<code>setOption(...)</code>
			<br /><code>setBlogOption(...)</code>(v2.2)
			<br /><code>setCategoryOption(...)</code>(v2.2)
			<br /><code>setMemberOption(...)</code>(v2.2)			      
			<br /><code>setItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">オプションに値をセットします。</a></td>		
	</tr>
	<tr>
		<td>
			<code>getOption(...)</code>
			<br /><code>getBlogOption(...)</code>(v2.2)
			<br /><code>getCategoryOption(...)</code>(v2.2)
			<br /><code>getMemberOption(...)</code>(v2.2)			       
			<br /><code>getItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">オプションの値を取得します。</a></td>		
	</tr>
	<tr>
		<td>
			<code>getAllBlogOptions(...)</code>(v2.2)
			<br /><code>getAllCategoryOptions(...)</code>(v2.2)
			<br /><code>getAllMemberOptions(...)</code>(v2.2)			       
			<br /><code>getAllItemOptions(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">与えられたオプションにより、すべての値（コンテクストごとの一つの値）の連想配列を返します。</a></td>		
	</tr>	
	<tr>
		<td>
			<code>getBlogOptionTop(...)</code>(v3.2)
			<br /><code>getMemberOptionTop(...)</code>(v3.2)
			<br /><code>getCategoryOptionTop(...)</code>(v3.2)
	  <br /><code>getItemOptionTop(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">与えられたオプションにより、すべての値のうちの最初の値を返します。</a></td>
	</tr>
	<tr>
		<td><code>getID()</code></td>
		<td>このプラグインのIDを返します（このIDはNucleus内部で利用されるものです）。</td>		
	</tr>
	<tr>
		<td><code>getAdminURL()</code></td>
		<td>プラグインの管理エリアが置かれたURLを返します（そのような管理エリアがない場合は、この情報は無効です）。</td>		
	</tr>
	<tr>
		<td><code>getDirectory()</code></td>
		<td>プラグインの追加ファイルが格納されたサーバーのファイルシステムのパスを返します（そのようなファイルがない場合は、この情報は無効です）。結果は&quot;<code>.../nucleus/plugins/<em>plugname</em>/</code>&quot;のようになります。</td>		
	</tr>
	<tr>
		<td><code>getShortName()</code></td>
		<td>"NP_"部分を省き、全てを小文字にしたプラグインのクラス名を返します。この情報は <code>getAdminURL</code> と <code>getDirectory</code> で使用されます。</td>		
	</tr>

</table>

<h1>スキン変数<a name="skinvars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>解説</h2>

<p>
独自のスキン変数を生成し、<code>&lt;%plugin(<em>PlugName,parameters</em>)%&gt;</code> または <code>&lt;%PlugName(parameters)%&gt;</code>で呼び出すことが出来ます（すでに存在するスキン変数とかぶらない場合）。パラメータはカンマ区切りです。</p>

<p>
スキン変数を扱うには、<code>doSkinVar</code> メソッドを実装する必要があります。いくつかの例を以下に示します。</p>

<pre class="example"><code>function doSkinVar($skinType)
function doSkinVar($skinType, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1 = 'default value')</code></pre>

<ul>
	<li><code>$skinType</code> パラメータは、'index', 'item', 'archive', 'archivelist', 'member', 'error',
  'search', 'imagepopup',  <a href="#templatevars" title="Information on templatevars">'template'</a>のうちの一つを取ります</li>
	<li><code>$skinVar</code> は、スキン変数のタイプとして解釈される実質的に最初のパラメータになります（例：<code>&lt;%plugin(PlugName,VarType)%&gt;</code>）。</li>
	<li><code>doSkinVar()</code>（パラメータ無し）を使い、PHPファンクションの<code>func_get_args()</code>を用いてパラメータを取得することができます。引数の数の異なる、タイプの違うスキン変数を扱うときに便利です。</li>
</ul>

<h2>ノート</h2>

<ul>
	<li>(v2.0b) グローバル変数としてパースされている <code>$currentSkinName</code> を使ってスキンの名前を取得できます。</li>
</ul>




<h1>テンプレート変数<a name="templatevars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>解説</h2>

<p>
テンプレートプラグイン変数はスキンプラグイン変数と同様に働きますが以下の2点が異なります。</p>

<ol>
	<li>スキン内ではなくテンプレート内から呼ばれます。</li>
	<li>$skinTypeパラメータを取りません。代わりに現在パースされているアイテムやコメントの情報付きの追加パラメータを取ります。
    <ul>
			<li><code>doTemplateVar</code> メソッドは <code>&amp;$item</code> パラメータを取ります。</li>
			<li><code>doTemplateCommentsVar</code> メソッドは <code>&amp;$item</code> と <code>&amp;$comment</code> パラメータを取ります。</li>
	  </ul>
		<strong>&amp;マークに注意！</strong>
	</li>
</ol>
	
<p>テンプレート変数はスキン変数と同じ要領で呼ばれます（<code>&lt;%plugin(PlugName,parameters)%&gt;</code> または <code>&lt;%PlugName(parameters)%&gt;</code>）。</p>

<p>
デフォルトでは、全てのテンプレート変数は'<code>template</code>'を<code>skintype</code>パラメータとして、<code>doSkinVar</code> メソッドに渡ります。</p>

<p>
独自の実装を提供したい場合は、<code>doTemplateVar</code> メソッドや <code>doTemplateCommentsVar</code> メソッドを再定義する必要があります。<code>skintype</code>パラメータが無くなる以外はdoSkinVarと同様に働きます。</p>

<pre class="example"><code>function doTemplateVar(&amp;$item)
function doTemplateVar(&amp;$item, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1 = 'default value')
function doTemplateCommentsVar(&amp;$item, &amp;$comment)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1 = 'default value')</code></pre>

<h2>ノート</h2>

<ul>
	<li>(v2.0b) グローバル変数として内部で利用される <code>$currentSkinName</code> を使ってテンプレートの名前を取得できます。</li>
</ul>




<h1>アクション<a name="actions" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>プラグインは <code>action.php</code> を通してアクションを行うことができ、同様のスクリプトがコメントや投票の受け取りにも使用されてます。GETまたはPOSTのどちらかを通して呼び出せます。必要なパラメータは
<code>action</code>（'plugin'と指定）、<code>name</code>（プラグイン名）、<code>type</code>（リクエストされたアクションの種類）です。</p>

<p>これらのアクションを有効にするために、<code>doAction($actionType)</code> メソッドをプラグイン内で実装する必要があります。リクエストからの追加パラメータは
<code>requestVar('<em>name</em>')</code> で取得できます（<code>requestVar</code> はPHPが付加する magic_quotes_gpc に配慮しています）。</p>

<p>
<code>doAction</code> メソッドが文字列を返すとき、エラーとして解釈され、エラーメッセージが表示されます。</p>






<h1>イベント<a name="events" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleusプラグインはなにか重要なことが起きたときに発生するイベントに登録可能です。プラグインはイベント発生の際にアクションを実行したり、テキストを出力したりできます。</p>

<h2>例</h2>

<p>
下記は <code>PreAddComment</code> イベント（blogにコメントが追加される直前に生成されるイベント）にプラグインが登録する例です。</p>

<pre class="example"><code>class NP_Acronyms extends NucleusPlugin {
  ...
  function getEventList() { return array('PreAddComment'); }
  ...
  function event_PreAddComment(&amp;$data) {
    // 頭字語 HTML を置き換え
    $data['comment']['body'] = 
        strreplace('HTML',
                   '&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;',
                   $data['comment']['body']);
  }
}
</code></pre>

<p>このプラグインはコメント中の'HTML'というテキストを'<code>&lt;acronym title=&quot;HyperText
Markup Language&quot;&gt;HTML&lt;/acronym&gt;</code>'に置き換えます。acronymタグはHTMLタグで、頭字語についての追加情報を提供します。</p>

<h2>イベント登録の仕方</h2>

<p>イベント登録に必要なステップは以下になります。</p>

<ol>
	<li><code>getEventList</code> メソッドから返る配列にイベント名を追加します。</li>
	<li><code>event_EventName($data)</code> という形でメソッドを生成し、この中でイベントを処理します。</li>
</ol>

<p>複数のプラグインが同じイベントに登録できます。管理エリアのプラグインリストの順序に従ってプラグインに通知が行きます。リストの上にあるプラグインほど早く通知されます。</p>

<h2>パラメータ</h2>

<p><code>event_EventName</code> メソッドはひとつだけ <code>$data</code> パラメータを持ち、それはイベントごとに内容が異なります。これは連想配列です。この連想配列に渡されたオブジェクトや配列は<strong>参照形式</strong>で渡されるため、これらに加えた変更は記憶されます。</p>

<p>以下のイベントリストは、パラメータ変更がNucleusに知られるかどうかを示すために色を使い分けています。</p>

<ul>
	<li><var class="ref">参照渡し（緑）</var>: この種のパラメータに変更を加えるとNucleusに知られます。</li>
	<li><var class="ro">値渡し（赤）</var>: プラグインイベントハンドラに渡される前に値がコピーされます。これらの変数への変更は自動的に破棄されます。.</li>
</ul>

<p>パラメータとして渡されるオブジェクトは<var class="obj">object</var>.として示されます。ほとんどのオブジェクトは参照渡しで、<var class="obj ref">object
by ref</var>のように示されます。</p>

<h2>イベントリスト</h2>

<table summary="An overview of events to which a Nucleus Plugin can subscribe, and what parameters are passed along to the method that handles the event">
	<caption>
	プラグインが登録できるイベント</caption>
	<tr>
		<th>名前</th>
		<th>いつ</th>
		<th>パラメータ</th>
	</tr>
	<tr>
		<td>InitSkinParse</td>
		<td>スキンの初期化の直前</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>パースする<code>SKIN</code>オブジェクト</dd>
			<dt class="ro">type</dt>
			<dd>スキンタイプ（'index', 'item', 'archive', 'archivelist',
			'member', 'error', 'search', 'imagepopup', 'fileparser'のいずれか)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreSkinParse</td>
		<td>スキンのパースの直前</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>パースする<code>SKIN</code>オブジェクト</dd>
			<dt class="ro">type</dt>
			<dd>スキンタイプ（'index', 'item', 'archive', 'archivelist',
		  'member', 'error', 'search', 'imagepopup', 'fileparser'のいずれか）</dd>
			<dt class="ref">contents</dt>
			<dd>スキンの内容</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostSkinParse</td>
		<td>スキンのパースの直後</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>パースする<code>SKIN</code>オブジェクト</dd>
			<dt class="ro">type</dt>
			<dd>スキンタイプ（'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search',
		  'imagepopup', 'fileparser'のいずれか）</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreItem</td>
		<td>アイテムのパース前、ただしアイテムヘッダーのパース後</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">item</dt>
			<dd>アイテムデータを持つオブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostItem</td>
		<td>アイテムのパース後、ただしアイテムフッターのパース前</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">item</dt>
			<dd>アイテムデータを持つオブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreComment</td>
		<td>コメントの表示前</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>コメントデータを持つ連想配列</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostComment</td>
		<td>コメントの表示後</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>コメントデータを持つ連想配列</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreDateHead</td>
		<td>日付ヘッダーのパース前</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">timestamp</dt>
			<dd>日付ヘッダーのタイムスタンプ</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDateHead</td>
		<td>日付ヘッダーのパース後</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">timestamp</dt>
			<dd>日付ヘッダーのタイムスタンプ</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreDateFoot</td>
		<td>日付フッターのパース前</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">timestamp</dt>
			<dd>日付フッターのタイムスタンプ</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDateFoot</td>
		<td>日付フッターのパース後</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">timestamp</dt>
			<dd>日付フッターのタイムスタンプ</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>LoginSuccess</td>
		<td>ログイン成功後</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd><code>MEMBER</code> オブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>LoginFailed</td>
		<td>ログイン失敗後</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>ログイン時に使われたユーザー名</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>Logout</td>
		<td>ログアウト後</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>ログアウト時のユーザー名</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreBlogContent</td>
		<td>blogの内容がスキン変数を通して挿入される前</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">type</dt>
			<dd>呼び出されたスキン変数 ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults',
			  'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostBlogContent</td>
		<td>blogの内容がスキン変数を通して挿入された後</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ro">type</dt>
			<dd>呼び出されたスキン変数 ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults',
		  'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreAddComment</td>
		<td>コメントがデータベースに追加される前</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>コメントデータ（連想配列）</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddComment</td>
		<td>コメントがデータベースに追加された後</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>コメントデータ（連想配列）</dd>
			<dt class="ref">commentid</dt>
			<dd>コメントのID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostRegister</td>
		<td>新規ユーザーの登録後</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd>新しい<code>MEMBER</code> オブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddItem</td>
		<td>アイテムがデータベースに追加された後</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>データベースに出来た新しい itemid</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostUpdateItem</td>
		<td>アイテムがデータベースにアップデートされた直後</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>アイテムのID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddItem</td>
		<td>アイテムがデータベースに追加される直前</td>
		<td><dl>
			<dt class="ref">title</dt>
			<dd>タイトル</dd>
			<dt class="ref">body</dt>
			<dd>本文</dd>
			<dt class="ref">more</dt>
			<dd>拡張テキスト</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ref">authorid</dt>
			<dd>執筆者ID</dd>
			<dt class="ref">timestamp</dt>
			<dd>UNIX タイムスタンプ</dd>
			<dt class="ref">closed</dt>
			<dd>1 （コメント不可） or 0 （コメント可）</dd>
			<dt class="ref">draft</dt>
			<dd>1 （ドラフト） or 0 （非ドラフト）</dd>
			<dt class="ref">catid</dt>
			<dd>カテゴリーID</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreUpdateItem</td>
		<td>データベースにあるアイテムが更新される直前</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>アイテム ID</dd>
			<dt class="ref">title</dt>
			<dd>タイトル</dd>
			<dt class="ref">body</dt>
			<dd>本文</dd>
			<dt class="ref">more</dt>
			<dd>拡張テキスト</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG オブジェクト</code> object</dd>
			<dt class="ref">closed</dt>
			<dd>1 （コメント不可） or 0 （コメント可）</dd>
			<dt class="ref">catid</dt>
			<dd>カテゴリーID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PrepareItemForEdit</td>
		<td>アイテムをデータベースから取得した直後で、編集のためにユーザーに表示される前</td>
		<td><dl>
			<dt class="ref">item</dt>
			<dd>アイテムデータを持つ連想配列</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreUpdateComment</td>
		<td>コメントが更新され、データベースに保存される直前</td>
		<td><dl>
			<dt class="ref">body</dt>
			<dd>コメント本文</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PrepareCommentForEdit</td>
		<td>コメントをデータベースから取得した直後で、編集のためにユーザーに表示される前</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>コメントデータ（連想配列）</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PrePluginOptionsEdit</td>
		<td>
			(v2.0b) 'プラグインオプションの編集'フォームが生成される前
			<br />(v2.2) パラメータ追加
			<br />(v3.2) 各オプションにパラメータ追加
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>blog</code>, <code>member</code>, <code>item</code>, <code>category</code>のいずれか</dd>
			<dt class="ref">options</dt>
			<dd>次のインデックスをもつ連想配列： <code>name</code>, <code>value</code>, <code>oid</code>, <code>description</code>, <code>type</code>, <code>typeinfo</code>, <code>contextid</code>, <code>extra</code> 。追加オプションをここに加えることも可能（それらで何かの処理をするときはPostPluginOptionsUpdateの記述も必要）<br />
			<code>extra</code>フィールドを用いて、オプションに追加HTML（たとえばフォームのコントロール）を追加できます。もしそうする場合、 <code>extra</code> に追加する前に <code>pid</code> と <code>getID()</code> を比較し、さらに <code>name</code> をチェックすべきです。</dd>
			<dt class="ro">plugid</dt>
			<dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）（コンテクストがglobalのときのみ存在）</dd>
			<dt class="ro">contextid</dt>
			<dd>コンテクスト ID (blogid, memberid, catid, itemid コンテクストによる)</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PrePluginOptionsUpdate</td>
		<td>
			(v3.2) プラグインオプションが更新される前。（このイベントを使ってオプションの新しい値を評価したり変更したりできます）
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code>, <code>category</code>のいずれか</dd>
			<dt class="ro">plugid</dt>
			<dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）</dd>
			<dt class="ro">optionname</dt>
			<dd>オプション名</dd>
			<dt class="ro">contextid</dt>
			<dd>コンテクスト ID (blogid, memberid, catid, itemid コンテクストによる)</dd>
			<dt class="ref">value</dt>
			<dd>そのオプションの新しい値</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostPluginOptionsUpdate</td>
		<td>
			(v2.0b) プラグインオプションの更新後<br />
		(v2.2) コンテクストによって異なるパラメータ</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code>, <code>category</code>のいずれか</dd>
			<dt class="ro">plugid</dt>
			<dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）（globalコンテクスト）</dd>
			<dt class="ro">blogid</dt>
			<dd>(v2.2) blog ID (blog コンテクスト)</dd>			
			<dt class="ref obj">blog</dt>
			<dd>(v2.2) BLOG オブジェクト (blog コンテクスト)</dd>			
			<dt class="ro">memberid</dt>
			<dd>(v2.2) member ID (member コンテクスト)</dd>			
			<dt class="ref obj">member</dt>
			<dd>(v2.2) MEMBER オブジェクト (member コンテクスト)</dd>			
			<dt class="ro">catid</dt>
			<dd>(v2.2) category ID (category コンテクスト)</dd>			
			<dt class="ro">itemid</dt>
			<dd>(v2.2) item ID (item コンテクスト)</dd>
			<dt class="ref obj">member</dt>
			<dd>(v2.2) ITEM オブジェクト (item コンテクスト)</dd>
		</dl></td>		
		
	</tr>	
	<tr>
		<td>PostAuthentication</td>
		<td>(v2.0b) ログイン処理の完了後。ページリクエストごとに発生</td>
		<td><dl>
			<dt class="ro">loggedIn</dt>
			<dd><code>$member->isLoggedIn()</code>の戻り値</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>PreAddItemForm</td>
		<td>(v2.0b) アイテム追加フォーム（ブックマークレットまたは管理エリア）が生成される直前</td>
		<td><dl>
			<dt class="ref">contents</dt>
			<dd>連想配列への参照。そのうちの'title',
			  'body', 'more'にはフォームフィールドへの初期値を与えることができます。複数のプラグイン間でこれらの値の変更を避けるには、処理後に'hasBeenSet'の値を1にセットします（かつ処理前にこの値をチェックするようにします）</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>AddItemFormExtras</td>
		<td>(v2.0b) アイテム追加ページまたはブックマークレット内部のどこか。<code>template</code> ファイルの類を別に用意しなくても、ここでプラグインがカスタムフィールドを追加できる。</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>			
	<tr>
		<td>EditItemFormExtras</td>
		<td>
			(v2.0b) アイテム編集ページまたはブックマークレット内部のどこか。<code>template</code> ファイルの類を別に用意しなくても、ここでプラグインがカスタムフィールドを追加できる。<br />
			<br />			
			あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。		  <pre class="example"><code>&lt;h3&gt;プラグイン名&lt;/h3&gt;
&lt;p&gt;追加フォームの内容&lt;/p&gt;</code></pre>
		このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクトへの参照</dd>
			<dt class="ro">variables</dt>
			<dd>
				(read-only) 編集されるアイテムに関する全ての情報を持つ連想配列： 'itemid',
				  'draft', 'closed', 'title', 'body', 'more', 'author', 'authorid',
				  'timestamp', 'karmapos', 'karmaneg', 'catid'
			</dd>			
			<dt class="ro">itemid</dt>
			<dd>アイテム IDへのショートカット</dd>
		</dl></td>		
	</tr>				
	<tr>
		<td>BlogSettingsFormExtras</td>
		<td>(v2.0) blog設定ページにフォームを追加可能<br /><br />			
			あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。		  <pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容&lt;/p&gt;&lt;/form&gt;</code></pre>
			このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreDeleteItem</td>
		<td>(v2.0) アイテムがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>削除されるアイテムID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteItem</td>
		<td>(v2.0) アイテムがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>削除されたアイテムID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreDeleteCategory</td>
		<td>(v2.0) カテゴリーがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>削除されるカテゴリー ID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteCategory</td>
		<td>(v2.0) カテゴリーがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>削除されたカテゴリー ID</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreDeleteBlog</td>
		<td>(v2.0) blogがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>削除されるblogID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteBlog</td>
		<td>(v2.0) blogがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>削除されたblogID</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreDeleteMember</td>
		<td>(v2.0) メンバーがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd><code>削除されるメンバーに関するMEMBER</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteMember</td>
		<td>(v2.0) メンバーがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd><code>削除されるメンバーに関するMEMBER</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreDeleteTeamMember</td>
		<td>(v2.0) メンバーがweblogチームから削除される直前</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> オブジェクトへの参照</dd>
			<dt class="ro">blogid</dt>
			<dd>blogID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteTeamMember</td>
		<td>(v2.0) メンバーがweblogチームから削除された直後</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> オブジェクトへの参照</dd>
			<dt class="ro">blogid</dt>
			<dd>blogID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreDeleteComment</td>
		<td>(v2.0) コメントがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>削除されるコメントID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteComment</td>
		<td>(v2.0) コメントがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>削除されたコメントID</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>ActionLogCleared</td>
		<td>(v2.0) アクションログが消去された後</td>
		<td>なし</td>		
	</tr>
	<tr>
		<td>PreDeleteTemplate</td>
		<td>(v2.0) テンプレートがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>削除されるテンプレートID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteTemplate</td>
		<td>(v2.0) テンプレートがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>削除されたテンプレートID</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>PreDeleteSkin</td>
		<td>(v2.0) スキンがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>削除されるスキンID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteSkin</td>
		<td>(v2.0) スキンがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>削除されたスキンID</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreDeletePlugin</td>
		<td>(v2.0) プラグインがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>削除されるプラグインID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeletePlugin</td>
		<td>(v2.0) プラグインがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>削除されたプラグインID</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>PreDeleteBan</td>
		<td>(v2.0) 禁止IPがデータベースから削除される直前</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>禁止IPが削除されるblogのID</dd>
			<dt class="ro">iprange</dt>
			<dd>禁止されたIPレンジ</dd>			
		</dl></td>		
	</tr>
	<tr>
		<td>PostDeleteBan</td>
		<td>(v2.0) 禁止IPがデータベースから削除された直後</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>禁止IPが削除されたblogのID</dd>
			<dt class="ro">iprange</dt>
			<dd>禁止されたIPレンジ</dd>			
		</dl></td>		
	</tr>			
	<tr>
		<td>PreAddCategory</td>
		<td>(v2.0) 新しいカテゴリーがデータベースに生成される直前</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクトの参照</dd>
			<dt class="ref">name</dt>
			<dd>新しいカテゴリー名</dd>			
			<dt class="ref">description</dt>
			<dd>新しいカテゴリーの説明</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddCategory</td>
		<td>(v2.0) 新しいカテゴリーがデータベースに生成された直後</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクトへの参照</dd>
			<dt class="ro">name</dt>
			<dd>新しいカテゴリー名</dd>			
			<dt class="ro">description</dt>
			<dd>新しいカテゴリーの説明</dd>
			<dt class="ro">catid</dt>
			<dd>新しいカテゴリー ID</dd>			
		</dl></td>		
	</tr>
	<tr>
		<td>PreAddBlog</td>
		<td>(v2.0) 新しいblogが生成される直前</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>新しい blog名</dd>
			<dt class="ref">shortname</dt>
			<dd>新しい blogの短縮名</dd>
			<dt class="ref">timeoffset</dt>
			<dd>新しい blogのタイムオフセット</dd>
			<dt class="ref">description</dt>
			<dd>新しい blogの説明</dd>
			<dt class="ref">defaultskin</dt>
			<dd>新しいblogのデフォルトスキンのID</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddBlog</td>
		<td>(v2.0) 新しいblogが生成された直後</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>新しい<code>BLOG</code> オブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreAddPlugin</td>
		<td>(v2.0) プラグインが追加される直前</td>
		<td><dl>
			<dt class="ref">file</dt>
			<dd>新しいプラグインのファイル名</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddPlugin</td>
		<td>(v2.0) プラグインが追加された直後</td>
		<td><dl>
			<dt class="ref obj">plugin</dt>
			<dd>新しく追加されたプラグインのオブジェクト</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreAddTeamMember</td>
		<td>(v2.0) メンバーがblogチームに追加される直前</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> オブジェクト</dd>
			<dt class="ref">admin</dt>
			<dd>新しく追加されたメンバーが管理権限を持っているかどうかを示すブール値</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddTeamMember</td>
		<td>(v2.0) メンバーがblogチームに追加された直後</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> オブジェクト</dd>
			<dt class="ro">admin</dt>
			<dd>新しく追加されたメンバーが管理権限を持っているかどうかを示すブール値</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PreAddTemplate</td>
		<td>(v2.0) 新しいテンプレートが生成される直前（注：テンプレートが複製されたときも呼ばれる）</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>新しいテンプレート名</dd>
			<dt class="ref">description</dt>
			<dd>新しいテンプレートの説明</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddTemplate</td>
		<td>(v2.0) 新しいテンプレートが生成された直後</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>新しいテンプレート名</dd>
			<dt class="ro">description</dt>
			<dd>新しいテンプレートの説明</dd>
			<dt class="ro">templateid</dt>
			<dd>新しいテンプレートID</dd>
		</dl></td>		
	</tr>	
	<tr>
		<td>PreAddSkin</td>
		<td>(v2.0) 新しいスキンが生成される直前（注：スキンが複製されたときも呼ばれる）</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>新しいスキン名</dd>
			<dt class="ref">description</dt>
			<dd>新しいスキン名の説明</dd>
			<dt class="ref">type</dt>
			<dd>スキンのコンテントタイプ</dd>
			<dt class="ref">includeMode</dt>
			<dd>新しいスキンのインクルードモード</dd>
			<dt class="ref">includePrefix</dt>
			<dd>新しいスキンのインクルードプレフィックス</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddSkin</td>
		<td>(v2.0) 新しいスキンが生成された直後</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>新しいスキン名</dd>
			<dt class="ro">description</dt>
			<dd>新しいスキンの説明</dd>
			<dt class="ro">type</dt>
			<dd>スキンのコンテントタイプ</dd>
			<dt class="ro">includeMode</dt>
			<dd>新しいスキンのインクルードモード</dd>
			<dt class="ro">includePrefix</dt>
			<dd>新しいスキンのインクルードプレフィックス</dd>
			<dt class="ro">skinid</dt>
			<dd>新しいスキンID</dd>
		</dl></td>		
	</tr>		
	<tr>
		<td>PreAddBan</td>
		<td>(v2.0) 新しい禁止IPが追加される直前</td>
		<td><dl>
			<dt class="ref">blogid</dt>
			<dd>blogID</dd>
			<dt class="ref">iprange</dt>
			<dd>禁止されたIPレンジ</dd>
			<dt class="ref">reason</dt>
			<dd>禁止された理由を記述したテキストメッセージ</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>PostAddBan</td>
		<td>(v2.0) 新しい禁止IPが追加された直後</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>blogID</dd>
			<dt class="ro">iprange</dt>
			<dd>禁止されたIPレンジ</dd>
			<dt class="ro">reason</dt>
			<dd>禁止された理由を記述したテキストメッセージ</dd>
		</dl></td>		
	</tr>		

	<tr>
		<td>PreMoveItem</td>
		<td>(v2.0) アイテムが他のblog/カテゴリーに移される直前</td>
		<td><dl>
			<dt class="ref">itemid</dt>
			<dd>アイテムID</dd>
			<dt class="ref">destblogid</dt>
			<dd>移動先のblogID</dd>
			<dt class="ref">destcatid</dt>
			<dd>移動先のカテゴリーID</dd>			
		</dl></td>		
	</tr>
	<tr>
		<td>PostMoveItem</td>
		<td>(v2.0) アイテムが他のblog/カテゴリーに移された直後</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>アイテムID</dd>
			<dt class="ro">destblogid</dt>
			<dd>新しいblogID</dd>
			<dt class="ro">destcatid</dt>
			<dd>新しいカテゴリーID</dd>	
		</dl></td>		
	</tr>
	<tr>
		<td>PreMoveCategory</td>
		<td>(v2.0) カテゴリーが他のblogに移される直前</td>
		<td><dl>
			<dt class="ref">catid</dt>
			<dd>カテゴリーID</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>移動元の<code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">destblog</dt>
			<dd>移動先の<code>BLOG</code> オブジェクト</dd>			
		</dl></td>		
	</tr>
	<tr>
		<td>PostMoveCategory</td>
		<td>(v2.0) カテゴリーが他のblogに移された直後</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>カテゴリーID</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>移動元の<code>BLOG</code> オブジェクト</dd>
			<dt class="ref obj">destblog</dt>
			<dd>移動先の<code>BLOG</code> オブジェクト</dd>			
		</dl></td>		
	</tr>	
	<tr>
		<td>MemberSettingsFormExtras</td>
		<td>(v2.0) メンバー設定ページにフォームを追加可能<br /><br />			
			あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
            <pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容&lt;/p&gt;&lt;/form&gt;</code></pre>
このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> オブジェクトへの参照</dd>
		</dl></td>		
	</tr>
	<tr>
		<td>GeneralSettingsFormExtras</td>
		<td>(v2.0) 一般設定ページにフォームを追加可能<br />
		  <br />
あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
<pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容&lt;/p&gt;&lt;/form&gt;</code></pre>
このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。</td>
		<td>なし</td>		
	</tr>
	<tr>
		<td>AdminPrePageHead</td>
		<td>(v2.5) 管理画面で、ページヘッドを出力する直前。このイベントはヘッド領域にスクリプトやCSSを追加するのに用いられます。</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>HTMLページのヘッド領域に埋め込まれる追加情報。ここに追加したいものを入れてください。</dd>
			<dt class="ro">action</dt>
			<dd>現在実行されているアクション、またはページタイプ</dd>
		</dl></td>
	</tr>
	<tr>
		<td>AdminPrePageFoot</td>
		<td>(v2.5) 管理画面で、ページフッターを出力する直前。</td>
	  <td><dl>
			<dt class="ro">action</dt>
			<dd></dd>
		</dl>
	    現在実行されているアクション、またはページタイプ</td>
	</tr>
	<tr>
		<td>PreSendContentType</td>
		<td>(v2.5) HTTPヘッダーにコンテントタイプがセットされる直前</td>
		<td><dl>
			<dt class="ref">contentType</dt>
			<dd>コンテントタイプ（<code>application/xhtml+xml</code>など）</dd>
			<dt class="ref">charset</dt>
			<dd>キャラクターセット</dd>
			<dt class="ro">pageType</dt>
			<dd>表示するページの種類を示す文字列：<code>skin</code> (スキンタイプ), <code>media</code> (メディアライブラリ), <code>admin-<em>action</em></code> (管理エリア), <code>bookmarklet-<em>action</em></code> (ブックマークレット)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>QuickMenu</td>
		<td>(v2.5) 管理エリアのクイックメニューの一番下。そこへのプラグイン登録に利用されます。登録するにはoptionsに連想配列を入れます。実装例が<a href="#admin">プラグイン管理エリアを作る</a>のセクションにあります。</td>
		<td><dl>
			<dt class="ref">options</dt>
			<dd>配列</dd>
		</dl></td>
	</tr>
	<tr>
		<td>BookmarkletExtraHead</td>
		<td>(v2.5) ブックマークレット
	  XHTMLコードのヘッド領域内。</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>XHTMLコードのヘッド領域に埋め込まれる追加情報。ここに追加したいものを入れてください。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>FormExtra</td>
		<td>(v3.2) このイベントは、プラグインがコメント、メンバー間メール、認証フォームのいずれかのフォーム内に追加フィールドを挿入するときに使います。フォーム処理の際に発生する <code>ValidateForm</code> イベントに対応します。</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>イベントを発生させるフォームタイプ
				<ul>
					<li><code>activation</code></li>
					<li><code>additemform</code> （注：これは管理画面のアイテム追加フォームではない）</li>
					<li><code>commentform-loggedin</code></li>
					<li><code>commentform-notloggedin</code></li>
					<li><code>membermailform-loggedin</code></li>
					<li><code>membermailform-notloggedin</code></li>
				</ul>
			</dd>
			<dt class="ro obj">member</dt>
			<dd><code>type</code> が <code>activation</code>のとき、このフィールドは認証メンバーの詳細情報を含みます</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ValidateForm</td>
		<td>(v3.2) コメント、メンバー間メール、アカウント認証のいずれかが処理されるときに呼ばれます。プラグインはこれで各データの評価を実行でき、もし不具合があれば処理を中断できます。<code>FormExtra</code> と共に使うとフォームにフィールドを追加できます。</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>処理されるフォームタイプ
				<ul>
					<li><code>membermail</code></li>
					<li><code>comment</code></li>
					<li><code>activation</code></li>
				</ul>
			</dd>
			<dt class="ref">error</dt>
			<dd>フォーム処理をストップするときに、<code>error</code> フィールドに空でないエラーメッセージを記入します。このエラーメッセージはユーザー側に表示されます。</dd>
			<dt class="ref">comment</dt>
			<dd>コメントフォームのとき、コメントデータに関する連想配列を含みます。</dd>
			<dt class="ro obj">member</dt>
			<dd>認証フォームのとき、認証中のメンバー情報を含みます。</dd>
		</dl></td>
	</tr>
<!--
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr> -->
</table>



<h1>オプションを保存する<a name="options" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>プラグインに簡単にオプションを登録・取得できるように一連のメソッドが用意されています。これらのオプションは直接Nucleusの管理エリアで編集でき、プラグイン自身の管理エリアを用意する必要もなく、PHPファイルそのものの中にオプションの値を書き込まずにすみます。</p>

<p>オプションは異なったコンテクストで利用可能です。</p>

<ol>
	<li><strong>グローバルオプション</strong>：管理エリアのプラグインセクションで編集可能</li>
	<li><strong>blogオプション</strong>：blog設定ページで編集可能</li>
	<li><strong>カテゴリーオプション</strong>：blog設定ページ（のカテゴリー編集ページ）で編集可能</li>	
	<li><strong>メンバーオプション</strong>：メンバー編集ページで編集可能</li>
	<li><strong>アイテムオプション</strong>：アイテムの追加、およびアイテムの編集ページで編集可能</li>
</ol>

<h2>オプションの種類</h2>

<p>オプションにはいくつかのタイプが提供されています。</p>

<dl>
	<dt>text</dt>
	<dd>シンプルなテキスト</dd>
	<dt>yesno</dt>
	<dd>'yes'か'no'どちらか（編集画面ではラジオボタンとして表示されます）</dd>
	<dt>password</dt>
	<dd>テキストフィールド (編集画面では伏字で表示されます)</dd>
	<dt>textarea (v2.2)</dt>
	<dd>複数行のテキストフィールド</dd>
	<dt>select (v2.2)</dt>
	<dd>ドロップダウンメニュー。次のような形式の追加情報が必要です： Option 1|value1|Option 2|value2|Option 3|value3 </dd>
</dl>

<h2>オプション・メタ</h2>

<p>Nucleus v3.2よりオプション・メタデータを用いて、オプションタイプを正しい値を受け取れるように制限できるようになりました。このメタデータは <code>$typeExtras</code>フィールドにセミコロン区切りのリストで保存されます。注：selectオプションでは、selectリストは<code>$typeExtras</code>のなかで一番最初でなければいけません。</p>

<table><tr>
	<th>キー</th>
	<th>説明</th>
</tr><tr>
	<td><code>datatype</code></td>
	<td>Nucleus本体に、どのデータ型を使いたいかという追加情報を与えます。現在は '<code>numerical</code>' のみ利用できます。 '<code>numerical</code>' を指定することでNucleusは数値情報のみを受け付けます（クライアントサイド・サーバサイド両方でチェック） （'<code>select</code>' と '<code>text</code>'のオプションタイプで利用できます）</td>
</tr><tr>
	<td><code>access</code></td>
	<td>'<code>readonly</code>'にセットすることで、オプションを編集不可能にします（'<code>text</code>' と '<code>textarea</code>'のオプションタイプで利用できます）<br />
	'<code>hidden</code>'を使うと、利用者側にそのオプションの存在を完全に隠蔽します（'<code>text</code>'のオプションタイプで利用できます）</td>
</tr></table>

<p>設定例</p>
<pre class="example"><code>// 数値のみを受け付けるテキストオプションを作成
$this->createBlogOption('FooBar', 'foobar', 'text', '0', 'datatype=numerical');
// 数値のみを受け付けるセレクトオプションを作成
$this->createItemOption('FooBar', 'foobar', 'select', '0', '0|0|1|1|2|2;datatype=numerical');
// 編集不可能なテキストエリアオプションを作成
$this->createOption('FooBar', 'foobar', 'textarea', 'This textarea is readonly', 'access=readonly');
</code></pre>

<h2>制限</h2>

<ol>
	<li>オプション名は最大20文字です。</li>
	<li>オプションの説明文は最大255文字です。</li>
	<li>オプションの値は制限ありません（v2.2より前のバージョンでは128文字の制限がありました）</li>
	<li>'=', '|', ';' のキャラクターはセレクトオプション用のセレクトリストやオプション・メタデータ中で使用することはできません。</li>
</ol>

<h2>メソッド</h2>

<h3>createOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>グローバル</strong>なコンテクストで新しいオプションを生成します。</p>

<table><tr>
	<th>パラメータ</th>
	<th>値</th>
</tr><tr>
	<td>$name</td>
	<td>オプション名</td>
</tr><tr>
	<td>$desc</td>
	<td>オプション編集画面で表示される説明文</td>
</tr><tr>
	<td>$type</td>
	<td>オプションタイプ（前出）</td>
</tr><tr>
	<td>$defValue</td>
	<td>初期値</td>
</tr><tr>
	<td>$typeExtras</td>
	<td>オプションタイプの追加情報（前出）</td>
</tr></table>

<h3>[v2.2] createBlogOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>blog</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v2.2] createCategoryOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>カテゴリー</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v2.2] createMemberOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>メンバー</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v3.2] createItemOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>アイテム</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>setOption($name, $value)</h3>

<p>すでにデータベースに存在するオプションの値を変更します。</p>

<table><tr>
	<th>パラメータ</th>
	<th>値</th>
</tr><tr>		
	<td>$name</td>
	<td>オプション名</td>
</tr><tr>
	<td>$value</td>
	<td>新しい値</td>
</tr></table>

<h3>[v2.2] setBlogOption($blogid, $name, $value)</h3>

<p>blogオプションの値を変更します。<code>blogid</code>属性はどのblogでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v2.2] setCategoryOption($catid, $name, $value)</h3>

<p>カテゴリーオプションの値を変更します。<code>catid</code>属性はどのカテゴリーでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v2.2] setMemberOption($memberid, $name, $value)</h3>

<p>メンバーオプションの値を変更します。<code>memberid</code>属性はどのメンバーでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v3.2] setItemOption($itemid, $name, $value)</h3>

<p>アイテムオプションの値を変更します。<code>itemid</code>属性はどのアイテムでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>getOption($name)</h3>

<p>データベース内のオプションの値を返します。</p>

<table><tr>
	<th>パラメータ</th>
	<th>値</th>
</tr><tr>		
	<td>$name</td>
	<td>オプション名</td>
</tr></table>

<h3>[v2.2] getBlogOption($blogid, $name)</h3>

<p>blogオプションの値を返します。<code>blogid</code>属性は値がリスエストされたblogを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>[v2.2] getCategoryOption($catid, $name)</h3>

<p>カテゴリーオプションの値を返します。<code>catid</code>属性は値がリスエストされたカテゴリーを示します（その他のオプション：<code>getOption</code>を参照）。<br />
</p>

<h3>[v2.2] getMemberOption($memberid, $name)</h3>

<p>メンバーオプションの値を返します。<code>memberid</code>属性は値がリスエストされたメンバーを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>[v3.2] getItemOption($itemid, $name)</h3>

<p>アイテムオプションの値を返します。<code>itemid</code>属性は値がリスエストされたアイテムを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>deleteOption($name)</h3>

<p>データベースからオプションを削除します。</p>

<table><tr>
	<th>パラメータ</th>
	<th>値</th>
</tr><tr>		
	<td>$name</td>
	<td>オプション名</td>
</tr></table>

<h3>[v2.2] deleteBlogOption($name)</h3>

<p>blogオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] deleteCategoryOption($name)</h3>

<p>カテゴリーオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] deleteMemberOption($name)</h3>

<p>メンバーオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v3.2] deleteItemOption($name)</h3>

<p>アイテムオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] getAllBlogOptions($name)</h3>

<p>与えられたblogオプションの全ての値を返します。結果は存在するblogidごとの連想配列です。</p>

<h3>[v2.2] getAllCategoryOptions($name)</h3>

<p>与えられたカテゴリーオプションの全ての値を返します。結果は存在するcatidごとの連想配列です。</p>

<h3>[v2.2] getAllMemberOptions($name)</h3>

<p>与えられたメンバーオプションの全ての値を返します。結果は存在するmemberidごとの連想配列です。</p>

<h3>[v3.2] getAllItemOptions($name)</h3>

<p>与えられたアイテムオプションの全ての値を返します。結果は存在するitemidごとの連想配列です。</p>

<h3>[v3.2] getBlogOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのblogid ('id') の値 ('value') を持つ配列になっています。</p>

<table><tr>
	<th>パラメータ</th>
	<th>値</th>
</tr><tr>
	<td>$name</td>
	<td>オプション名</td>
</tr><tr>
	<td>$amount</td>
	<td>必要なオプション数</td>
</tr><tr>
	<td>$sort</td>
	<td>昇順 ('asc') か降順 ('desc') で並べ替え</td>
</tr></table>

<h3>[v3.2] getMemberOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのメンバーID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>

<h3>[v3.2] getCategoryOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのカテゴリーID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>


<h3>[v3.2] getItemOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのアイテムID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>


<div class="note">
<b>注：</b> プラグインクラス内のコンストラクタから、これらのファンクションを呼ぶことはできません。プラグインがロードされた後にこれらを実行したいときは、かわりに<code>init()</code>メソッド内に置きます。</div>

<h1>データベース・テーブル<a name="tables" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Nucleusテーブルへのアクセス</h2>

<p>v2.0まで、Nucleusテーブルへのアクセスは単に<code>nucleus_</code>と名づけられたテーブルに対してSQL命令を実行するだけのものでした。Nucleusのバージョン2.2以降はカスタム・テーブル名を利用できるようになったため、プラグイン開発に若干注意する必要があります。</p>

<ol>
	<li><code>nucleus_item</code> などの固定されたテーブル名の代わりに、テーブル名のプレフィックスを生成するために <code>sql_table('item') </code>というグローバルファンクションを利用します。</li>
	<li><code>supportsFeature('SqlTablePrefix')</code> が呼ばれたときにプラグインが1（真）を返すようにします。これがないと、カスタムプレフィックスがセットされている場合でバージョンが2.0より大きいNucleusではプラグインをロードできません（用心のため）。</li>
</ol>

<p class="note">v2.0までのNucleusではグローバルファンクション <code>sql_table</code> は利用できないことに注意してください。もしこのメソッドを用いつつ、プラグインをv2.0以下のNucleusで動作させたい場合は、以下のコードをプラグインクラスの前に追加してください。</p>

<pre class="example"><code>&lt;?

// プラグインがNucleusバージョン2.0以下と互換性を持つために必要
if (!function_exists('sql_table'))
{
	function sql_table($name) {
		return 'nucleus_' . $name;
	}
}

class NP_HelloWorld extends NucleusPlugin {
...
}

?&gt;</code></pre>

<h2>独自テーブル</h2>

<p>もしプラグイン独自のテーブルが必要なら、<code>install</code>メソッドの中で独自テーブルを生成し、<code>unInstall</code>メソッドの中でそれを削除するようにします。</p>

<p>いくつかの注意点</p>
<ul>
	<li><code>nucleus_plug_<em>plugname</em></code> のように、他のプラグインと競合しないテーブル名を考えてください。カスタムプレフィックスに対応するため、テーブル名を
	<code>sql_table('plug_plugname')</code> で生成してください。
	</li>
	<li>自分自身でデータベース接続をする必要はありません。PHPコマンド <code>mysql_query()</code> を使ってSQL命令を実行できます。</li>
	<li>自分でデータベース接続をする場合、後でNucleusデータベースへの接続を復元するようにしてください。自前処理の後で <code>sql_connect()</code>  を呼ぶことで可能です。頻繁な再接続を避けるために、コンストラクタでそれを行うのも良いです。<code>$this- &gt;db</code>のリンクIDを保持でき、各クエリにそれを渡すことができます。</li>
	<li>バックアップ機能を使う時は、独自テーブルもバックアップに含めるよう、<code>getTableList()</code> を再定義してください。</li>
</ul>

<h1>プラグイン管理エリア<a name="admin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Ver2.5から、Nucleusの管理エリアに統合されたプラグイン管理エリアを作成できます。これらのページは従来のプラグイン管理ページや左側のクイックメニューからアクセスできます。</p>

<h2>基本</h2>

<p>管理エリアを提供するには、次のステップが必要です。</p>

<ol>
  <li>プラグインディレクトリに<strong>プラグイン名</strong>のサブディレクトリを作ります。たとえばプラグイン名が<code>NP_PluginName</code>なら、'pluginname'です。ディレクトリ名はすべて小文字で！</li>
  <li>
  	そのディレクトリで、次のような<strong>index.php</strong>を用意します。
  	<pre><code>&lt;?php

	// if your 'plugin' directory is not in the default location,
	// edit this variable to point to your site directory
	// (where config.php is)
	$strRel = '../../../';

	include($strRel . 'config.php');
	if (!$member->isLoggedIn())
		doError('You\'re not logged in.');

	include($DIR_LIBS . 'PLUGINADMIN.php');

	// create the admin area page
	$oPluginAdmin = new PluginAdmin('<strong>PluginName</strong>');
	$oPluginAdmin->start();

	echo '&lt;h2&gt;プラグイン名&lt;/h2&gt;';

	echo '&lt;p&gt;<strong>ページ内容</strong>&lt;p&gt;';

	$oPluginAdmin->end();

?&gt;</code></pre>
  </li>
  <li>
  	プラグイン側に次のコードを挿入し、クイックメニューイベントに登録します。
    <pre><code>function event_QuickMenu(&amp;$data) {
		array_push(
			$data['options'],
			array(
				'title' => '<strong>プラグイン名</strong>',
				'url' => $this->getAdminURL(),
				'tooltip' => '<strong>ツールチップテキスト</strong>'
			)
		);
	}</code></pre>
  </li>
  <li>
  	プラグイン側に次の関数を記述します。
    <pre><code>function hasAdminArea()
{
	return 1;
}</code></pre>
  </li>
</ol>

<h2>考慮すること</h2>

<ul>
 <li>登録できるからといって安易にクイックメニューへ登録しないこと。クイックメニューにプラグインが100個並んだりしたらかなりウンザリするでしょう。ですので、クイックメニューに登録する場合でも、クイックメニュー登録を有効・無効化するプラグインオプションを（グローバルまたはメンバーオプションで）用意することを考えてください。</li>
 <li><code>プラグインディレクトリが nucleus/plugins/ ではない場合は、index.php内の $strRel</code> 変数は手動で書き換える必要があります。</li>
 <li>管理エリアのアウトプットが<strong>正しいXHTML</strong>になっているか確認してください。正しくないと、MozillaなどのGeckoベースのブラウザでページ表示が崩れます。</li>
</ul>

<h2>PluginAdmin クラス</h2>

<p><code>PluginAdmin</code> クラスは助けになります。これを一度生成すれば、<code>$oPluginAdmin->plugin</code> でプラグインのインスタンスにアクセスできます。</p>

<h1>プラグイン用ヘルプページ <a name="help" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Nucleus v3.2から、プラグインの機能の概要、利用できるスキン・テンプレート変数、さらに詳細な情報のありかなどを示すヘルプページを提供可能になりました。</p>

<p>ヘルプページは管理画面のプラグイン一覧からアクセス可能になります。</p>

<h2>基本</h2>
<p>ヘルプページを提供するために、次のステップが必要です。</p>
<ol>
<li>プラグインディレクトリに、プラグイン名をつけたサブディレクトリを作成します。ディレクトリ名は小文字であることに注意します。<a href="#admin">管理エリア</a>を作るときと同様です。</li>
<li>そのディレクトリの中に help.html を作り、プラグインについての文章を記述します。次の雛型からはじめると良いでしょう。
<pre><code>&lt;h3&gt;プラグインの概要&lt;/h3&gt;

&lt;p&gt;このプラグインはヘルプページがいかに機能するかを示すためだけのものです&lt;/p&gt;

&lt;h3&gt;インストール&lt;/h3&gt;

&lt;p&gt;これを読めてるならインストールは正しく出来てます :-)&lt;/p&gt;

&lt;h3&gt;スキン変数&lt;/h3&gt;

&lt;p&gt;このプラグインはただのテストケースなのでスキン・テンプレート変数はありませんが、書くとすれば。

&lt;ul&gt;&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1%&gt;&lt;/b&gt;: なにかをする&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1(foobar)%&gt;&lt;/b&gt;: 別のなにかをする&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;サポートとバグ報告&lt;/h3&gt;

&lt;p&gt;さらなるサポートやバグ報告のために、次のフォーラムのスレッドを利用してください。
&lt;a href="http://forum.nucleuscms.org/viewtopic.php?t=&lt;トピックID&gt;"&gt;
http://forum.nucleuscms.org/viewtopic.php?t=&lt;トピックID&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;バージョン履歴&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;Version 0.1: 最初のテストケースバージョン&lt;/li&gt;
&lt;li&gt;Version 0.0: その前のバージョン ;-)&lt;/li&gt;&lt;/ul&gt;</code></pre>
</li>
<li>supportsFeature('HelpPage') で0より大きい数字を返すように設定します。
<pre><code>function supportsFeature($what) {
	switch($what) {
	case 'HelpPage':
		return 1;
	  default:
		return 0;
	}
  }</code></pre>
</li>
</ol>

<h1>プラグイン依存チェック <a name="dependency" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>v3.2から、他のプラグインとの依存関係を宣言する新しいプラグインインターフェイスが追加されました。他のプラグインの機能を必要とするプラグインに利用できます。特に依存関係が成立しなくて正しく機能しない状態を検知するときに便利です。</p>

<h2>この機能を利用するプラグインの書き方</h2>

<p>現実世界での例からはじめましょう。</p>

<p>NP_PageLinkList は NP_BlogWithOffset の機能を利用するため、利用者には NP_BlogWithOffset のインストール後に NP_PageLinkList をインストールさせたいとします。NucleusはこのAPIによって、インストール前に依存関係を検知させる方法をプラグインに提供します。</p>

<p>このケースでは、NP_PageLinkList 側に NP_BlogWithOffset が必要だということを認識させるコードを埋め込みます。プラグインがインストールされる際に、Nucleusコアは <code>getPluginDep()</code> というファンクションを呼び出します。このファンクションは必要なプラグインのリストを返し、コアはインストール済みのプラグインをチェックして、もし依存関係に欠如があればインストールを拒否します。</p>

<p>必要なことは NP_PageLinkList にこのファンクションを追加する、ただそれだけです。</p>

<pre><code>function getPluginDep() {
	 return array('NP_BlogWithOffset');
}</code></pre>

<p>このプラグイン依存チェックは、他のプラグインが依存しているプラグインがアンインストールされることも防ぎます。</p>

</body>
</html>


