<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<!-- $Id$ -->
	<title>Nucleus - Plugin API</title>
	<link rel="stylesheet" type="text/css" href="styles/manual.css" />
	<style type="text/css">
		/* refence parameters (greenish) */
		.ref {
			background-color: #afa;
			color: #000;
		}

		/* object parameters */
		.obj {
			color: #00f;
		}
		.obj:after {
			content: " (object)";
		}

		/* read-only parameters (non-ref; reddish) */
		.ro {
			background-color: #faa;
			color: #000;
		}
	</style>
</head>
<body>

<div class="heading">
Plugin API
<i>November 29, 2005</i>
</div>

<div class="note"><strong>Notes:</strong>
	<ul>
		<li>This document should contain enough information to write basic plugins. If you have more questions, see the <a href="http://forum.nucleuscms.org/viewforum.php?f=10">Plugin Development Forum</a></li>
		<li>Methods and events introduced after Nucleus v1.5 was released have the Nucleus version in which they were introduced listed. If you use any of those functions, don't forget to adapt <code>getMinNucleusVersion</code> appropriately.
		</li>
  </ul>
</div>

<h1>Introduction</h1>

<p>
<a href="index.html">Back to the developer docs index</a>
</p>

<p>
This document contains information on how you can write your own Nucleus plugins
</p>

<h1><a name="toc"></a><a name="top"></a>Table Of Contents</h1>

<ul>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#firstplug">Writing your first plugin</a></li>
	<li><a href="#nucleusplugin">Overview of the <code>NucleusPlugin</code> class</a></li>
	<li><a href="#skinvars">The <code>&lt;%plugin(...)%&gt;</code> skinvar</a></li>
	<li><a href="#templatevars">The <code>&lt;%plugin(...)%&gt;</code> templatevar</a></li>
	<li><a href="#actions">Actions using <code>action.php</code></a></li>
	<li><a href="#events">Events, and subscribing to them</a></li>
	<li><a href="#options">Saving options</a></li>
	<li><a href="#tables">Database tables</a></li>
	<li><a href="#admin">Providing an admin area</a></li>
	<li><a href="#help">Providing a helppage</a></li>
	<li><a href="#dependency">Plugin Dependency Check</a></li>
<!--	<li><a href="#parser">Using the <code>PARSER</code> class</a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>
	<li><a href="#"></a></li>-->
</ul>

<h1>Introduction <a name="introduction" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleus plugins allow just about anyone to extend the functionality that Nucleus offers, without having to alter the PHP code itself. Plugins are simple php scripts that must implement certain methods, and can easily be exchanged between Nucleus users. Installing goes as easy as adding the plugin file to the plugin directory and letting Nucleus know it's there.
</p>

<p>
Some advantages of plugins are listed below:
</p>

<ul>
	<li>Extra functionality can easily be added to the Nucleus framework, without having to know much details about the implementation.</li>
	<li>You can install only the plugins you need, saving on the time needed to generate a page</li>
</ul>

<p>
All plugin files should be placed in the directory that is listed in <code>config.php</code>. Commonly, this will be <code>/your/path/nucleus/plugins/</code>. Plugin files can be recognized by their form: <code>NP_<i>name</i>.php</code>. Some plugins require a subdirectory with the same <i>name</i> to store extra files or their admin area.
</p>

<div class="note">
<b>Note:</b> the names are case-sensitive, so they should start with <code>NP_</code>, not <code>Np_</code> or <code>np_</code>. Also note that when the plugin uses a subdirectory, the name of that directory should be <em>all lowercase</em>.
</div>




<h1>Writing your first plugin <a name="firstplug" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Ok, lets start by writing a simple plugin. Basically, each plugin is a PHP class that inherits from the predefined class <code>NucleusPlugin</code>. Below is an example of a <code>HelloWorld</code>-plugin:
</p>

<pre class="example"><code>&lt;?php

class NP_HelloWorld extends NucleusPlugin
{
	// name of plugin
	function getName()
	{
		return 'Hello World';
	}

	// author of plugin
	function getAuthor()
	{
		return 'Wouter Demuynck';
	}

	// an URL to the plugin website
	// can also be of the form mailto:foo@bar.com
	function getURL()
	{
		return 'http://nucleuscms.org/';
	}

	// version of the plugin
	function getVersion()
	{
		return '1.0';
	}

	// a description to be shown on the installed plugins listing
	function getDescription()
	{
		return 'Just a sample plugin.';
	}

	function doSkinVar($skinType)
	{
		echo 'Hello World!';
	}

	function supportsFeature ($what)
	{
		switch ($what)
		{
			case 'SqlTablePrefix':
				return 1;
			default:
				return 0;
		}
	}

}
?&gt;</code></pre>

<ol>
	<li>
		Copy this code in a file called <code>NP_HelloWorld.php</code>, and put it in your plugins directory. <em>Make sure that there are no spaces after the last <code>?&gt;</code> or before the first <code>&lt;?php</code>.</em>. NP stands for "Nucleus Plugin", if you were wondering about that.
	</li>
	<li>Open the Nucleus Administration area and go into <em>Nucleus Management/Manage Plugins</em></li>
	<li>You'll find out that there's a <em>HelloWorld</em> plugin you can install. Do this. If everything worked out correctly, you'll see that your plugin is now listed in the list of installed plugins.</li>
	<li>
		Now edit one of your skins and insert the following statement at a place of which you know where it will show up on the actual page.
<pre class="example"><code>&lt;%HelloWorld%&gt;</code></pre>
		Note that the name (<code>HelloWorld</code>) is case sensitive!
	</li>
	<li>Now visit a page that uses the skin you edited: notice the "Hello World" at the location where you've added the <code>plugin</code>-skinvar.</li>
</ol>

<p>
So, that wasn't so hard after all. Read on to find out more.
</p>







<h1>The class NucleusPlugin <a name="nucleusplugin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>All Nucleus plugins must inherit from the PHP class <code>NucleusPlugin</code>. If this sounds complicated, don't worry, it isn't. It even makes your life easier, allowing you to only implement the methods that your plugin needs, and giving access to some auxiliary functions.</p>

<p>Below is an overview of the methods that the <code>NucleusPlugin</code> offers, and that you can re-implement in your own plugin. If you want to see the source of the class itsself, it's located at <code>nucleus/libs/PLUGIN.php</code></p>

<table summary="An overview of the redefinable methods in the class NucleusPlugin">
	<caption>Overview of the class <code>NucleusPlugin</code> (redefinable methods)</caption>
	<tr>
		<th>Method&nbsp;Signature</th><th>Explanation</th>
	</tr>
	<tr>
		<td><code>getName()</code></td>
		<td>Returns the name of the plugin. This will be the name that will show up on the list of installed plugins. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getAuthor()</code></td>
		<td>Returns the name of author of the plugin. This name will show up on the list of installed plugins. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getURL()</code></td>
		<td>Returns the URL of the site where the plugin can be downloaded, or where additional information about the plugin can be found. If no such site exists, a <code>mailto:</code>-link with the authors email address is appropriate. You should definately redefine this method, since the default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getDescription()</code></td>
		<td>Returns a longer description of the plugin. This will show up on the list of installed plugins. The default implementation returns <q>Undefined</q></td>
	</tr>
	<tr>
		<td><code>getVersion()</code></td>
		<td>Returns the current version of the plugin. Returns <q>0.0</q> by default</td>
	</tr>
	<tr>
		<td><code>getMinNucleusVersion()</code></td>
		<td>(v2.0b) Returns the minimum required Nucleus version. By default, this returns <code>155</code> (v1.55). If you are using plugin features that were introduced later, please implement this function (e.g. v2.0 => 200). Please note that Nucleus v1.55 does not use this function at all, so it remains possible to install newer plugins there, even if they use newer features.</td>
	</tr>
	<tr>
		<td><code>getMinNucleusPatchLevel()</code></td>
		<td>(v3.1) Returns the minimum required Nucleus patch level that needs to be present when running the minimal required Nucleus version (<code>getMinNucleusVersion</code>). By default, this returns <code>0</code>. This function is generally used when new plugin features are available only as patches to the latest released Nucleus version.</td>
	</tr>
	<tr>
		<td><code>init()</code></td>
		<td>Initializes the plugin. This method gets called immediately after the plugin object is created and the <code>plugid</code>-attribute has been set. By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>doSkinVar($skinType)</code></td>
		<td>When plugins are called using the <code>&lt;%plugin(...)%&gt;</code>-skinvar, this method will be called. the <code>$skinType</code> parameter contains the type of skin (<code>item</code>, <code>archive</code>, ...) from where the plugin is called. Don't get confused by the fact that there's only one parameter. Multiple parameters <strong>can</strong> still be passed. <a href="#skinvars">More info on implementing the <code>doSkinVar</code> method.</a> By default, this method does no output at all.</td>
	</tr>
	<tr>
		<td><code>doTemplateVar(&amp;$item)</code></td>
		<td>Basically the same as <code>doSkinVar</code>, but this time for calls of the &lt;%plugin(...)%&gt;-var in <i>templates</i> (item header/body/footer and dateheader/footer). By default, this method forwards the handling to the <code>doSkinVar</code>-method, using <code>template</code> as skintype. <a href="#templatevars">More information on implementing the <code>doTemplateVar</code> method</a></td>
	</tr>
	<tr>
		<td><code>doTemplateCommentsVar(&amp;$item, &amp;$comment)</code></td>
		<td>(v2.0b) Basically the same as <code>doSkinVar</code>, but this time for calls of the &lt;%plugin(...)%&gt;-var in <i>templates</i> (comments-related parts). By default, this method forwards the handling to the <code>doSkinVar</code>-method, using <code>template</code> as skintype. <a href="#templatevars">More information on implementing the <code>doTemplateCommentsVar</code> method</a></td>
	</tr>
	<tr>
		<td><code>doAction($type)</code></td>
		<td>When a plugin wants to allow user interaction, it can allow actions through <code>action.php</code>. This is the script that Nucleus uses itself to handle new comments and karma votes. Called with the correct parameters, the <code>doAction</code>-method from a plugin can be called. The <code>$type</code> contains an optional message type. Extra variables from the request can be accessed from within the <code>doAction</code> method. By default, this method returns a string <q>No Such Action</q> which will trigger an error message. <a href="#actions">More info on <code>doAction</code>.</a></td>
	</tr>
	<tr>
		<td><code>install()</code></td>
		<td>This method gets called on the moment the plugin is installed. It can perform initializing actions, such as the creation of database tables, the creation of plugin options, etc... By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>unInstall()</code></td>
		<td>Called when the plugin is uninstalled. It's a good thing to clean up information your plugin created in the database at this point. By default, this method does nothing.</td>
	</tr>
	<tr>
		<td><code>getEventList()</code></td>
		<td>Plugins can subscribe to events. Events get generated whenever Nucleus performs a certain action. An <code>AddItem</code> event for example, will call all plugins that subscribed to this event. The called method will be <code>event_AddItem($params)</code>. The <code>$params</code>-parameter is an associative array containing several fields of information, like the itemid for <code>AddItem</code>. Returns an empty array by default, indicating that the plugin does not subscribe to any event at all. <a href="#events">More information about events.</a></td>
	</tr>
	<tr>
		<td><code>getTableList()</code></td>
		<td>This method should return an array of database tables that the plugin has created. It's used in the backup feature that Nucleus offers, so plugin tables are also included in the backup. By default, returns an empty array.</td>
	</tr>
	<tr>
		<td><code>hasAdminArea()</code></td>
		<td>Should return <code>1</code> if the plugin has an admin area of its own, and <code>0</code> if it doesn't. By default, <code>0</code> is returned.</td>
	</tr>
	<tr>
		<td><code>getPluginDep()</code></td>
		<td>(v3.2) Returns an array of plugin names. Nucleus refuses to install the plugin if any of these plugins is not installed. By default, an empty array is returned. <a href="#dependency">More information on plugin dependencies.</a></td>
	</tr>
</table>

<p>Next to the methods that can be implemented, the class <code>NucleusPlugin</code> offers some extra methods which you <em>should not</em> implement yourself. They can be called from within your plugin using the <code>$this-&gt;functionName()</code> syntax.</p>

<table summary="An overview of the auxiliary methods in the class NucleusPlugin. You should NOT redefine these">
	<caption>Overview of the class <code>NucleusPlugin</code> (non-redefinable methods)</caption>
	<tr>
		<th>Method&nbsp;Signature</th><th>Explanation</th>
	</tr>
	<tr>
		<td>
				  <code>createOption(...)</code>
			<br /><code>createBlogOption(...)</code>(v2.2)
			<br /><code>createCategoryOption(...)</code>(v2.2)
			<br /><code>createMemberOption(...)</code>(v2.2)
	  <br /><code>createItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Creates a new option</a></td>
	</tr>
	<tr>
		<td>
				  <code>deleteOption(...)</code>
			<br /><code>deleteBlogOption(...)</code>(v2.2)
			<br /><code>deleteCategoryOption(...)</code>(v2.2)
			<br /><code>deleteMemberOption(...)</code>(v2.2)
	  <br /><code>deleteItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Deletes an option</a></td>
	</tr>
	<tr>
		<td>
				  <code>setOption(...)</code>
			<br /><code>setBlogOption(...)</code>(v2.2)
			<br /><code>setCategoryOption(...)</code>(v2.2)
			<br /><code>setMemberOption(...)</code>(v2.2)
	  <br /><code>setItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Sets the value of an option</a></td>
	</tr>
	<tr>
		<td>
				  <code>getOption(...)</code>
			<br /><code>getBlogOption(...)</code>(v2.2)
			<br /><code>getCategoryOption(...)</code>(v2.2)
			<br /><code>getMemberOption(...)</code>(v2.2)
	  <br /><code>getItemOption(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">Retrieves the value of an option</a></td>
	</tr>
	<tr>
		<td>
			<code>getAllBlogOptions(...)</code>(v2.2)
			<br /><code>getAllCategoryOptions(...)</code>(v2.2)
			<br /><code>getAllMemberOptions(...)</code>(v2.2)
	  <br /><code>getAllItemOptions(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">For a given option, returns an associative of all values (one value per context)</a></td>
	</tr>

  <tr>
		<td>
			<code>getBlogOptionTop(...)</code>(v3.2)
			<br /><code>getMemberOptionTop(...)</code>(v3.2)
			<br /><code>getCategoryOptionTop(...)</code>(v3.2)
	  <br /><code>getItemOptionTop(...)</code>(v3.2)
		</td>
		<td><a href="#options" title="More info on options">For a given option, returns the top of all values</a></td>
	</tr>
	<tr>
		<td><code>getID()</code></td>
		<td>Returns the ID for this plugin (this is the ID internally used inside Nucleus)</td>
	</tr>
	<tr>
		<td><code>getAdminURL()</code></td>
		<td>Returns the URL of where the admin area of the plugin is located (if there is no such admin area, this information is invalid)</td>
	</tr>
	<tr>
		<td><code>getDirectory()</code></td>
		<td>Returns the path in the servers filesystem where the extra files for the plugin are stored (if there are no such files, this information makes no sense). The result is something like "<code>.../nucleus/plugins/<i>plugname</i>/</code>"</td>
	</tr>
	<tr>
		<td><code>getShortName()</code></td>
		<td>Returns the part of the plugin classname without the "<code>NP_</code>"-part, and in all-lowercase. This information is used in the functions <code>getAdminURL</code> and <code>getDirectory</code></td>
	</tr>

</table>

<h1>Skinvars <a name="skinvars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Description</h2>

<p>
You can create your own skinvars, and call them using <code>&lt;%plugin(<i>PlugName</i>,<i>parameters</i>)%&gt; </code> or <code>&lt;%PlugName(parameters)%&gt;</code> (when this does not conflict with an existing skinvar). Parameters are comma-separated.
</p>

<p>
To handle skinvars, you'll need to implement the <code>doSkinVar</code> method. Some samples of signatures are given below:
</p>

<pre class="example"><code>function doSkinVar($skinType)
function doSkinVar($skinType, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1 = 'default value')</code></pre>

<ul>
	<li>The <code>$skinType</code> parameter will be one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup' or <a href="#templatevars" title="Information on templatevars">'template'</a></li>
	<li>The <code>$skinVar</code> is actually the first parameter that's being interpreted as a type of skinvar (e.g. <code>&lt;%plugin(PlugName,VarType)%&gt;</code>)</li>
	<li>You can use <code>doSkinVar()</code> (no parameters) and retrieve the parameters using the PHP function <code>func_get_args()</code>. Could be handy if you have different types of skinvars with different numbers of arguments</li>
</ul>

<h2>Notes</h2>

<ul>
	<li>(v2.0b) You can find the name of the skin that's currently being parsed in the global variable <code>$currentSkinName</code></li>
</ul>




<h1>Template variables <a name="templatevars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Description</h2>

<p>
Template plugin variables work in the same way as skin plugin vars. There are two differences:</p>

<ol>
	<li>They are called from within templates instead of from within skins</li>
	<li>They don't take a <code>$skinType</code> parameter. Instead, they take extra parameters with info on the item and comment that is currently being parsed:
		<ul>
			<li>The <code>doTemplateVar</code>-method gets a <code>&amp;$item</code> parameter.</li>
			<li>The <code>doTemplateCommentsVar</code>-method gets an <code>&amp;$item</code> parameter as well as a <code>&amp;$comment</code> parameter.</li>
		</ul>
		<strong>Note the ampersands!</strong>
	</li>
</ol>

<p>Template variables are called in exactly the same way as skinvars (using <code>&lt;%plugin(<i>PlugName</i>,<i>parameters</i>)%&gt; </code> or <code>&lt;%PlugName(parameters)%&gt;</code>)
</p>

<p>
By default, all template variables are passed on to the <code>doSkinVar</code>-method, using '<code>template</code>' as <code>skinType</code>-parameter.
</p>

<p>
If you want to provide your own implementation, you'll need to redefine the method <code>doTemplateVar</code> and/or <code>doTemplateCommentsVar</code>. It works in the same way as <code>doSkinVar</code>, except that now the <code>skinType</code>-parameter is missing.
</p>

<pre class="example"><code>function doTemplateVar(&amp;$item)
function doTemplateVar(&amp;$item, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1 = 'default value')
function doTemplateCommentsVar(&amp;$item, &amp;$comment)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1 = 'default value')</code></pre>

<h2>Notes</h2>

<ul>
	<li>(v2.0b) You can find the name of the template that's currently being used inside the global variable <code>$currentTemplateName</code></li>
</ul>




<h1>Actions <a name="actions" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Plugins can perform actions through <code>action.php</code>, the same script that's being used to receive comments and karma votes. You can call it using both GET and POST methods. Required parameters are <code>action</code> (should be 'plugin'), <code>name</code> (name of the plugin) and <code>type</code> (type of requested action)</p>

<p>To enable these actions, you should implement the <code>doAction($actionType)</code> method in your plugin. Extra parameters from the request can be received using <code>requestVar('<i>name</i>')</code> (<code>requestVar</code> takes care of magic_quotes_gpc that PHP might have added)</p>

<p>
When your <code>doAction</code> method returns a string, it will be interpreted as an error, and an error message will be shown.
</p>






<h1>Events <a name="events" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleus Plugins can subscribe to events that occur whenever something important happens. The plugin can then execute some actions, or output some text.
</p>

<h2>Example</h2>

<p>
Below is an example of how a plugin subscribes to the <code>PreAddComment</code>-event, an event that is generated immediately before a comment is added to a blog.
</p>

<pre class="example"><code>class NP_Acronyms extends NucleusPlugin {
  ...
  function getEventList() { return array('PreAddComment'); }
  ...
  function event_PreAddComment(&amp;$data) {
	// replace acronym HTML
	$data['comment']['body'] =
		strreplace('HTML',
				   '&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;',
				   $data['comment']['body']);
  }
}
</code></pre>

<p>This plugin replaces the text <code>HTML</code> in each comment by the text <code>&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;</code>. The <code>acronym</code>-tag is a <acronym title="HyperText Markup Language">HTML</acronym>-tag that allows authors to provide extra information on acronyms.</p>

<h2>Subscribing to events</h2>

<p>Here's the steps you need to take to subscribe to an event:</p>

<ol>
	<li>Add the event name to the array returned by the <code>getEventList</code>-method</li>
	<li>Create a method with signature <code>event_<em>EventName</em>($data)</code>, in which the handling of the event is done</li>
</ol>

<p>Multiple plugins can subscribe to the same event. The order in which these plugins are notified is the same order as the ordening in the plugin list of the admin area. Plugins higher in the list get notified earlier on.</p>

<h2>Parameters</h2>

<p>The <code>event_<em>EventName</em></code>-method gets only one parameter, <code>$data</code>, of which the contents differs depending on the event. It is an associative array with data. Objects and arrays that are passed in this array, are passed by <strong>reference</strong>, so the changes you make there will be remembered.</p>

<p>The event list below uses some colors to indicate if changes in the parameters will be seen by nucleus or not:</p>

<ul>
	<li><var class="ref">pass-by-reference</var>: when changes are made to this kind of parameters, they will be seen by Nucleus.</li>
	<li><var class="ro">pass-by-value</var>: a copy of the value is made before it is sent to the plugin event handler. Changes in the contents of these variables will be discarded automatically.</li>
</ul>

<p>Objects that are passed as parameters are indicates as follows: <var class="obj">object</var>. Most objects are also passed by reference, making them look like <var class="obj ref">object by ref</var></p>

<h2>Event List</h2>

<table summary="An overview of events to which a Nucleus Plugin can subscribe, and what parameters are passed along to the method that handles the event">
	<caption>Events on which a plugin can subscribe</caption>
	<tr>
		<th>Name</th><th>When</th><th>Parameters</th>
	</tr>
	<tr>
		<td>InitSkinParse</td>
		<td>Just before the skin is initialized</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreSkinParse</td>
		<td>Immediately before the parsing of a skin begins</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
			<dt class="ref">contents</dt>
			<dd>The content of the skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostSkinParse</td>
		<td>Immediately after parsing a skin</td>
		<td><dl>
			<dt class="obj ref">skin</dt>
			<dd>The <code>SKIN</code>-object that is handling the parse</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinpart (one of 'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreItem</td>
		<td>Before an item is parsed, but after the item header has been placed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">item</dt>
			<dd>object containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostItem</td>
		<td>After an item has been parsed, but before the item footer has been parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">item</dt>
			<dd>object containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreComment</td>
		<td>Before a comment is shown</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>associative array containing comment data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostComment</td>
		<td>After a comment has been shown</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>associative array containing comment data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDateHead</td>
		<td>Before a date header is shown</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for date header</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDateHead</td>
		<td>After a date header has been parsed</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for date header</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDateFoot</td>
		<td>Before a date footer is parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for day that is closed</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDateFoot</td>
		<td>After a date footer has been parsed</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">timestamp</dt>
			<dd>Timestamp for day that is closed</dd>
		</dl></td>
	</tr>
	<tr>
		<td>LoginSuccess</td>
		<td>After a successful login</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd><code>MEMBER</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>LoginFailed</td>
		<td>After a failed login</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>login name that was used in the login attempt</dd>
		</dl></td>
	</tr>
	<tr>
		<td>Logout</td>
		<td>After logout</td>
		<td><dl>
			<dt class="ro">username</dt>
			<dd>name of the user that logged out</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreBlogContent</td>
		<td>Before blog content has been inserted through a skinvar</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinvar that's being called ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostBlogContent</td>
		<td>After blog content has been inserted through a skinvar</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ro">type</dt>
			<dd>Type of skinvar that's being called ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddComment</td>
		<td>Before adding a comment to the database</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
			<dt class="ref">spamcheck</dt>
			<dd>the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddComment</td>
		<td>After adding a comment to the database</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
			<dt class="ref">commentid</dt>
			<dd>comment ID</dd>
			<dt class="ref">spamcheck</dt>
			<dd>the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostRegister</td>
		<td>After a new user has registered</td>
		<td><dl>
			<dt class="obj ref">member</dt>
			<dd>New <code>MEMBER</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddItem</td>
		<td>After an item has been added to the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>new itemid in database</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostUpdateItem</td>
		<td>Immediately after an item gets updates in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>item ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddItem</td>
		<td>Immediately before an item is added to the database</td>
		<td><dl>
			<dt class="ref">title</dt>
			<dd>title</dd>
			<dt class="ref">body</dt>
			<dd>body text</dd>
			<dt class="ref">more</dt>
			<dd>extended text</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref">authorid</dt>
			<dd>ID of author</dd>
			<dt class="ref">timestamp</dt>
			<dd>UNIX timestamp</dd>
			<dt class="ref">closed</dt>
			<dd>1 (no comments allowed) or 0 (comments allowed)</dd>
			<dt class="ref">draft</dt>
			<dd>1 (draft) or 0 (not draft)</dd>
			<dt class="ref">catid</dt>
			<dd>ID fo category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreUpdateItem</td>
		<td>Immediately before an item gets updates in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>item ID</dd>
			<dt class="ref">title</dt>
			<dd>title</dd>
			<dt class="ref">body</dt>
			<dd>body text</dd>
			<dt class="ref">more</dt>
			<dd>extended text</dd>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref">closed</dt>
			<dd>1 (no comments allowed) or 0 (comments allowed)</dd>
			<dt class="ref">catid</dt>
			<dd>ID fo category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrepareItemForEdit</td>
		<td>Called after getting an item from the database, and before presenting it to the user to be edited.</td>
		<td><dl>
			<dt class="ref">item</dt>
			<dd>associative array containing item data</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreUpdateComment</td>
		<td>Immediately before a comment is updated and saved into the database</td>
		<td><dl>
			<dt class="ref">body</dt>
			<dd>Comment body</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrepareCommentForEdit</td>
		<td>After a comment is retrieved from the database, and before it is presented to the user to be edited.</td>
		<td><dl>
			<dt class="ref">comment</dt>
			<dd>comment data (associative array)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrePluginOptionsEdit</td>
		<td>
			(v2.0b) before the 'edit plugin options' form is created.
			<br />(v2.2) extra parameters
	  <br />(v3.2) extra parameter for every option
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>blog</code>, <code>member</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ref">options</dt>
			<dd>Array with for each option an associative array, having the following indices: <code>name</code>, <code>value</code>, <code>oid</code>, <code>description</code>, <code>type</code>, <code>typeinfo</code>, <code>contextid</code>, <code>extra</code>. Extra options can be added here (if you want to do something with them, you'll need to subscribe to PostPluginOptionsUpdate as well)<br />
	  Using the <code>extra</code>-field you can add extra html (by example formcontrols) to the option. If you do so, you should compare <code>pid</code> with <code>getID()</code> and also check <code>name</code> before adding things to <code>extra</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you) (only present when context is global)</dd>
			<dt class="ro">contextid</dt>
			<dd>context ID (blogid, memberid, catid, itemid depending on context)</dd>

		</dl></td>
	</tr>
  <tr>
		<td>PrePluginOptionsUpdate</td>
		<td>
			(v3.2) Before the options for a plugin have been updated. (using this event you can validate/change the new value for an option)
		</td>
		<td><dl>
	  <dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you)</dd>
	  <dt class="ro">optionname</dt>
			<dd>Name of the option</dd>
			<dt class="ro">contextid</dt>
			<dd>context ID (blogid, memberid, catid, itemid depending on context)</dd>
			<dt class="ref">value</dt>
			<dd>New value for the option</dd>
		</dl></td>

	</tr>

	<tr>
		<td>PostPluginOptionsUpdate</td>
		<td>
			(v2.0b) After the options for a plugin have been updated.
			<br />(v2.2) Different parameters depending on context
		</td>
		<td><dl>
			<dt class="ro">context</dt>
			<dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code> or <code>category</code></dd>
			<dt class="ro">plugid</dt>
			<dd>plugin ID (compare with <code>GetID()</code> to find out if this concerns you) (global context)</dd>
			<dt class="ro">blogid</dt>
			<dd>(v2.2) blog ID (blog context)</dd>
			<dt class="ref obj">blog</dt>
			<dd>(v2.2) BLOG object (blog context)</dd>
			<dt class="ro">memberid</dt>
			<dd>(v2.2) member ID (member context)</dd>
			<dt class="ref obj">member</dt>
			<dd>(v2.2) MEMBER object (member context)</dd>
			<dt class="ro">catid</dt>
			<dd>(v2.2) category ID (category context)</dd>
	  <dt class="ro">itemid</dt>
			<dd>(v2.2) item ID (item context)</dd>
	  <dt class="ref obj">member</dt>
			<dd>(v2.2) ITEM object (item context)</dd>
		</dl></td>

	</tr>
	<tr>
		<td>PostAuthentication</td>
		<td>(v2.0b) After the login procedure has been completed. This occurs on each page request.</td>
		<td><dl>
			<dt class="ro">loggedIn</dt>
			<dd>result of <code>$member->isLoggedIn()</code></dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddItemForm</td>
		<td>(v2.0b) Immediately before an add item form (bookmarklet or admin area) is created.</td>
		<td><dl>
			<dt class="ref">contents</dt>
			<dd>reference to an associative array, in which the values 'title', 'body' and 'more' can be filled with initial values for the formfields. To avoid multiple plugins to alter these values, set the 'hasBeenSet' value to 1 when you're done (and check for it before starting)</dd>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>AddItemFormExtras</td>
		<td>(v2.0b) Somewhere inside the add item page or bookmarklet. Here, plugins can add their custom fields without having to alter one of the <code>.template</code> files.</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>EditItemFormExtras</td>
		<td>
			(v2.0b) Somewhere inside the edit item page or bookmarklet. Here, plugins can add their custom fields without having to alter one of the <code>.template</code> files.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h3&gt;plugin name&lt;/h3&gt;
&lt;p&gt;your stuff&lt;/p&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)
		</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
			<dt class="ro">variables</dt>
			<dd>
				(read-only) An associative array containing all sorts of information on the item that's being edited: 'itemid', 'draft', 'closed', 'title', 'body', 'more', 'author', 'authorid', 'timestamp', 'karmapos', 'karmaneg', 'catid'
			</dd>
			<dt class="ro">itemid</dt>
			<dd>shortcut to the item ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>BlogSettingsFormExtras</td>
		<td>(v2.0) On the blog settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td><dl>
			<dt class="obj ref">blog</dt>
			<dd>reference to a <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteItem</td>
		<td>(v2.0) Immediately before an item gets deleted in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>id of the item that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteItem</td>
		<td>(v2.0) Immediately after an item has been deleted in the database</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>id of the deleted item</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteCategory</td>
		<td>(v2.0) Immediately before a category gets deleted from the database</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteCategory</td>
		<td>(v2.0) Immediately after a category has been deleted from the database</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteBlog</td>
		<td>(v2.0) Immediately before a blog gets deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteBlog</td>
		<td>(v2.0) Immediately after a blog has been deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog that was deleted from the database</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteMember</td>
		<td>(v2.0) Immediately before a member gets deleted from the database</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object associated with the member that needs to be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteMember</td>
		<td>(v2.0) Immediately after a member has been deleted from the database</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object associated with the member that has been deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteTeamMember</td>
		<td>(v2.0) Immediately before a member gets deleted from a weblog team</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object</dd>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteTeamMember</td>
		<td>(v2.0) Immediately after a member has been deleted from a weblog team</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to the <code>MEMBER</code> object</dd>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteComment</td>
		<td>(v2.0) Immediately before a comment gets deleted from the database</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>ID of the comment that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteComment</td>
		<td>(v2.0) Immediately after a comment has been deleted from the database</td>
		<td><dl>
			<dt class="ro">commentid</dt>
			<dd>ID of the deleted comment</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ActionLogCleared</td>
		<td>(v2.0) After the action log has been cleared</td>
		<td>None</td>
	</tr>
	<tr>
		<td>PreDeleteTemplate</td>
		<td>(v2.0) Immediately before a template gets deleted from the database</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>ID of the template that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteTemplate</td>
		<td>(v2.0) Immediately after a template has been deleted from the database</td>
		<td><dl>
			<dt class="ro">templateid</dt>
			<dd>ID of the deleted template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteSkin</td>
		<td>(v2.0) Immediately before a skin gets deleted from the database</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>ID of the skin that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteSkin</td>
		<td>(v2.0) Immediately after a skin has been deleted from the database</td>
		<td><dl>
			<dt class="ro">skinid</dt>
			<dd>ID of the deleted skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeletePlugin</td>
		<td>(v2.0) Immediately before a plugin gets deleted from the database</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>ID of the plugin that will be deleted</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeletePlugin</td>
		<td>(v2.0) Immediately after a plugin has been deleted from the database</td>
		<td><dl>
			<dt class="ro">plugid</dt>
			<dd>ID of the deleted plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreDeleteBan</td>
		<td>(v2.0) Immediately before an IP ban gets deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog for which the ban will be deleted</dd>
			<dt class="ro">iprange</dt>
			<dd>banned IP range</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostDeleteBan</td>
		<td>(v2.0) Immediately after an IP ban has been deleted from the database</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog for which the ban has been deleted</dd>
			<dt class="ro">iprange</dt>
			<dd>banned IP range</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddCategory</td>
		<td>(v2.0) Immediately before a new category is created in the database</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to <code>BLOG</code> object</dd>
			<dt class="ref">name</dt>
			<dd>name of new category</dd>
			<dt class="ref">description</dt>
			<dd>description of new category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddCategory</td>
		<td>(v2.0) Immediately after a new category has been created in the database</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>reference to <code>BLOG</code> object</dd>
			<dt class="ro">name</dt>
			<dd>name of new category</dd>
			<dt class="ro">description</dt>
			<dd>description of new category</dd>
			<dt class="ro">catid</dt>
			<dd>New category ID</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddBlog</td>
		<td>(v2.0) Immediately before a new blog is created</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of new blog</dd>
			<dt class="ref">shortname</dt>
			<dd>shortname of new blog</dd>
			<dt class="ref">timeoffset</dt>
			<dd>time offset of new blog</dd>
			<dt class="ref">description</dt>
			<dd>description of new blog</dd>
			<dt class="ref">defaultskin</dt>
			<dd>ID of default skin for new blog</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddBlog</td>
		<td>(v2.0) Immediately after a new blog has been created</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd>new <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddPlugin</td>
		<td>(v2.0) Immediately before a plugin is added</td>
		<td><dl>
			<dt class="ref">file</dt>
			<dd>filename of the new plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddPlugin</td>
		<td>(v2.0) Immediately after a plugin has been added</td>
		<td><dl>
			<dt class="ref obj">plugin</dt>
			<dd>An object of the newly added plugin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddTeamMember</td>
		<td>(v2.0) Immediately before a member gets added to a blog team</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> object</dd>
			<dt class="ref">admin</dt>
			<dd>boolean indicating if the newly added member will have blog admin rights or not</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddTeamMember</td>
		<td>(v2.0) Immediately after a member has been added to a blog team</td>
		<td><dl>
			<dt class="ref obj">blog</dt>
			<dd><code>BLOG</code> object</dd>
			<dt class="ref obj">member</dt>
			<dd><code>MEMBER</code> object</dd>
			<dt class="ro">admin</dt>
			<dd>boolean indicating if the newly added member has admin rights or not</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddTemplate</td>
		<td>(v2.0) Immediately before a new template is created (note: this one also gets called when a template is cloned))</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of the new template</dd>
			<dt class="ref">description</dt>
			<dd>description of the new template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddTemplate</td>
		<td>(v2.0) Immediately after a new template has been created</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>name of the new template</dd>
			<dt class="ro">description</dt>
			<dd>description of the new template</dd>
			<dt class="ro">templateid</dt>
			<dd>ID of the new template</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddSkin</td>
		<td>(v2.0) Immediately before a new skin is created (note: this one also gets called when a skin is cloned))</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>name of the new skin</dd>
			<dt class="ref">description</dt>
			<dd>description of the new skin</dd>
			<dt class="ref">type</dt>
			<dd>content type of the skin</dd>
			<dt class="ref">includeMode</dt>
			<dd>includeMode of the new skin</dd>
			<dt class="ref">includePrefix</dt>
			<dd>includePrefix of the new skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddSkin</td>
		<td>(v2.0) Immediately after a new skin has been created</td>
		<td><dl>
			<dt class="ro">name</dt>
			<dd>name of the new skin</dd>
			<dt class="ro">description</dt>
			<dd>description of the new skin</dd>
			<dt class="ro">type</dt>
			<dd>content type of the skin</dd>
			<dt class="ro">includeMode</dt>
			<dd>includeMode of the new skin</dd>
			<dt class="ro">includePrefix</dt>
			<dd>includePrefix of the new skin</dd>
			<dt class="ro">skinid</dt>
			<dd>ID of the new skin</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreAddBan</td>
		<td>(v2.0) Immediately before a new ban is added to a weblog</td>
		<td><dl>
			<dt class="ref">blogid</dt>
			<dd>ID of the blog</dd>
			<dt class="ref">iprange</dt>
			<dd>IP range to be banned</dd>
			<dt class="ref">reason</dt>
			<dd>textual message describing the reason for the ban</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostAddBan</td>
		<td>(v2.0) Immediately after a new ban has been added</td>
		<td><dl>
			<dt class="ro">blogid</dt>
			<dd>ID of the blog</dd>
			<dt class="ro">iprange</dt>
			<dd>IP range to be banned</dd>
			<dt class="ro">reason</dt>
			<dd>textual message describing the reason for the ban</dd>
		</dl></td>
	</tr>

	<tr>
		<td>PreMoveItem</td>
		<td>(v2.0) Immediately before an item is moved to another blog/category</td>
		<td><dl>
			<dt class="ref">itemid</dt>
			<dd>ID of the item</dd>
			<dt class="ref">destblogid</dt>
			<dd>ID of the destination blog</dd>
			<dt class="ref">destcatid</dt>
			<dd>ID of the destination category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostMoveItem</td>
		<td>(v2.0) Immediately after an item has been moved to another blog/category</td>
		<td><dl>
			<dt class="ro">itemid</dt>
			<dd>ID of the item</dd>
			<dt class="ro">destblogid</dt>
			<dd>ID of the new blog</dd>
			<dt class="ro">destcatid</dt>
			<dd>ID of the new category</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreMoveCategory</td>
		<td>(v2.0) Immediately before a catgeory is moved to another blog</td>
		<td><dl>
			<dt class="ref">catid</dt>
			<dd>ID of the catgeory</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>source <code>BLOG</code> object</dd>
			<dt class="ref obj">destblog</dt>
			<dd>destination <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostMoveCategory</td>
		<td>(v2.0) Immediately after a catgeory has been moved to another blog</td>
		<td><dl>
			<dt class="ro">catid</dt>
			<dd>ID of the catgeory</dd>
			<dt class="ref obj">sourceblog</dt>
			<dd>source <code>BLOG</code> object</dd>
			<dt class="ref obj">destblog</dt>
			<dd>destination <code>BLOG</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>MemberSettingsFormExtras</td>
		<td>(v2.0) On the member settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td><dl>
			<dt class="ref obj">member</dt>
			<dd>reference to a <code>MEMBER</code> object</dd>
		</dl></td>
	</tr>
	<tr>
		<td>GeneralSettingsFormExtras</td>
		<td>(v2.0) On the general settings page. You can add your own forms here.
			<br /><br />
			Don't add too much data, and please generate <strong>valid XHTML</strong>, looking like this:
<pre class="example"><code>&lt;h4&gt;plugin name&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
your stuff
&lt;/p&gt;&lt;/form&gt;</code></pre>
			This way, multiple plugins can add options here while things keep a good structure. Also try to use prefixes for your fieldnames, in order to avoid nameclashes (e.g. <code>plug_tb_url</code>)

		</td>
		<td>None</td>
	</tr>
	<tr>
		<td>AdminPrePageHead</td>
		<td>(v2.5) On admin area pages, immediately before the page head is printed. This event could be used to add extra script/css includes in the head section</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>Extra information to be included in the head section of the HTML page. Append your extras here.</dd>
			<dt class="ro">action</dt>
			<dd>Currently executed action or pagetype</dd>
		</dl></td>
	</tr>
	<tr>
		<td>AdminPrePageFoot</td>
		<td>(v2.5) On admin area pages, immediately before the page footer is printed.</td>
		<td><dl>
			<dt class="ro">action</dt>
			<dd></dd>
		</dl>Currently executed action or pagetype</td>
	</tr>
	<tr>
		<td>PreSendContentType</td>
		<td>(v2.5) Immediately before a content type is being set in the HTTP header</td>
		<td><dl>
			<dt class="ref">contentType</dt>
			<dd>content type (e.g. <code>application/xhtml+xml</code>)</dd>
			<dt class="ref">charset</dt>
			<dd>Character set</dd>
			<dt class="ro">pageType</dt>
			<dd>String indicating which type of page we're displaying: <code>skin</code> (skinparts), <code>media</code> (media library), <code>admin-<em>action</em></code> (admin area), <code>bookmarklet-<em>action</em></code> (bookmarklet)</dd>
		</dl></td>
	</tr>
	<tr>
		<td>QuickMenu</td>
		<td>(v2.5) At the end of the Admin Area quick menu. This can be used to add extra plugin entries. To add entries, push associative arrays on the <code>options</code> array. An example can be found in the section about <a href="#admin">creating a plugin admin area</a>.</td>
		<td><dl>
			<dt class="ref">options</dt>
			<dd>Array</dd>
		</dl></td>
	</tr>
	<tr>
		<td>BookmarkletExtraHead</td>
		<td>(v2.5) Somewhere inside the <code>head</code> section of the bookmarklet XHTML code.</td>
		<td><dl>
			<dt class="ref">extrahead</dt>
			<dd>Information to be included in the <code>head</code> section of the XHTML code. Add your extras here.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>FormExtra</td>
		<td>(v3.2) Inside one of the comment, membermail or account activation forms. This event allows plugins to insert extra fields in the form. This event corresponds with the <code>ValidateForm</code> event that is fires when the form is handled.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the form from which the event fired.
				<ul>
					<li><code>activation</code></li>
					<li><code>additemform</code> (note: this is not the add item form from the admin area!)</li>
					<li><code>commentform-loggedin</code></li>
					<li><code>commentform-notloggedin</code></li>
					<li><code>membermailform-loggedin</code></li>
					<li><code>membermailform-notloggedin</code></li>
				</ul>
			</dd>
			<dt class="ro obj">member</dt>
			<dd>When <code>type</code> is <code>activation</code>, this field contains the details of the member that's being activated</dd>
		</dl></td>
	</tr>
	<tr>
		<td>ValidateForm</td>
		<td>(v3.2) Called when one of the comment, membermail or account activation forms is being handled. This event allows plugins to perform their own validation on the data, and prevent further handling if something is wrong. When used together with the <code>FormExtra</code> field, it can be used to add extra fields to forms.</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>Type of the form being handled
				<ul>
					<li><code>membermail</code></li>
					<li><code>comment</code></li>
					<li><code>activation</code></li>
				</ul>
			</dd>
			<dt class="ref">error</dt>
			<dd>When the plugin wants to stop the handling of the form, it needs to fill out a non-empty error string message in this <code>error</code> field. This error message will then be presented to the user.</dd>
			<dt class="ref">comment</dt>
			<dd>On <code>comment</code>-type forms, contains an associative array with the comment data.</dd>
			<dt class="ref">spamcheck</dt>
			<dd>On <code>comment</code>-type forms, the resulting datastructure of the previously called <code>SpamCheck</code> event (associative array)</dd>
			<dt class="ro obj">member</dt>
			<dd>On <code>activation</code>-type forms, contains information about the member being activated.</dd>
		</dl></td>
	</tr>
	<tr>
		<td>SpamCheck</td>
		<td>(v3.3) Called when a new comment is added. This event allows anti-spam plugins to mark this comment as spam. A complete descriptions of the <code>SpamCheck</code> event can be found in a seperate document: <a href='http://wakka.xiffy.nl/spamcheck_api'>SpamCheck API 2.0</a>.</td>
		<td><dl>
			<dt class="ref">spamcheck</dt>
			<dd>The spamcheck datastructure</dd>
		</dl></td>
	</tr>
<!--
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td><dl>
			<dt></dt>
			<dd></dd>
		</dl></td>
	</tr> -->
</table>



<h1>Saving options <a name="options" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>A series of methods are offered to make it easy for plugins to set and retrieve options. These options can be directly edited from inside the Nucleus admin area, taking the need away for the plugin to provide an admin area of its own, and avoiding that options need to be set inside the PHP file itself.</p>

<p>Options are available in different contexts:</p>

<ol>
	<li><strong>Global options</strong>: Editable on the admin area from the plugins section.</li>
	<li><strong>Blog options</strong>: Editable from the blogsettings pages.</li>
	<li><strong>Category options</strong>: Editable from the blogsettings pages (on the 'edit category' page).</li>
	<li><strong>Member options</strong>: Editable on the 'edit member' pages</li>
  <li><strong>Item options</strong>: Editable on the 'add item' or 'edit item' pages</li>
</ol>

<h2>Option types</h2>

<p>Several types of options are provided</p>

<dl>
	<dt>text</dt>
	<dd>Simple text</dd>
	<dt>yesno</dt>
	<dd>Either the value '<code>yes</code>' or the value '<code>no</code>' (on edit, shown as radio button)</dd>
	<dt>password</dt>
	<dd>Text field (starred on edit)</dd>
	<dt>textarea (v2.2)</dt>
	<dd>Text field with multiple rows and columns</dd>
	<dt>select (v2.2)</dt>
	<dd>Drop down menu. Needs extra info in the following form: <code>Option 1|value1|Option 2|value2|Option 3|value3</code>
	</dd>
</dl>

<h2>Option meta</h2>

<p>As of Nucleus v3.2, some option types can be limited to only accept certain values using option-metadata. This metadata is stored in the <code>$typeExtras</code>-field, and is a semicolon-seperated list of values. Note: In a select-option, the select list must be the first value in <code>$typeExtras</code>.</p>

<table><tr>
	<th>key</th>
	<th>explanation</th>
</tr><tr>
	<td><code>datatype</code></td>
	<td>Using '<code>datatype</code>' you can give some extra hints to Nucleus about the datatype you want to use. Currently only '<code>numerical</code>' is available. '<code>numerical</code>' will cause Nucleus to only accept numerical values for this option (using both client-side and server-side check) (available for optiontypes: '<code>select</code>' and '<code>text</code>')</td>
</tr><tr>
	<td><code>access</code></td>
	<td>If set to '<code>readonly</code>', the option will not be editable (available for optiontypes: '<code>text</code>' and '<code>textarea</code>')<br />
	If set to '<code>hidden</code>', the option will be completely hidden for the end-user (available for optiontypes: '<code>text</code>')</td>
</tr></table>

<p>some examples:</p>
<pre class="example"><code>// following code creates a text-option that only accepts numerical values
$this->createBlogOption('FooBar', 'foobar', 'text', '0', 'datatype=numerical');
// following code creates a select-option that only accepts numerical values
$this->createItemOption('FooBar', 'foobar', 'select', '0', '0|0|1|1|2|2;datatype=numerical');
// following code creates a textarea-option that is readonly
$this->createOption('FooBar', 'foobar', 'textarea', 'This textarea is readonly', 'access=readonly');
</code></pre>

<h2>Restrictions</h2>

<ol>
	<li>The name of an option can contain a maximum of 20 characters</li>
	<li>The description of an option can contain a maximum of 255 characters</li>
	<li>The value for an option has no limit (Prior to v2.5 the limit was 128 characters)</li>
  <li>The characters '=', '|' and ';' can not be used inside a select list (for a select-option), or in option-metadata</li>
</ol>

<h2>The methods</h2>

<h3>createOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates a new option in the <strong>global</strong> context</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$desc</td>
	<td>Textual description, to be shown on the page where options can be edited</td>
</tr><tr>
	<td>$type</td>
	<td>Option type (see above)</td>
</tr><tr>
	<td>$defValue</td>
	<td>Initial value</td>
</tr><tr>
	<td>$typeExtras</td>
	<td>Extra info on option type (see above)</td>
</tr></table>

<h3>[v2.2] createBlogOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <strong>blog</strong> context (see <code>createOption</code>)</p>

<h3>[v2.2] createCategoryOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>category</code> context (see <code>createOption</code>)</p>

<h3>[v2.2] createMemberOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>member</code> context (see <code>createOption</code>)</p>

<h3>[v3.2] createItemOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p>Creates an option in the <code>item</code> context (see <code>createOption</code>)</p>

<h3>setOption($name, $value)</h3>

<p>changes the value of an option that was already in the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$value</td>
	<td>New value for option</td>
</tr></table>

<h3>[v2.2] setBlogOption($blogid, $name, $value)</h3>

<p>Changes the value for a blog option. The <code>blogid</code> attribute indicates for which blog the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v2.2] setCategoryOption($catid, $name, $value)</h3>

<p>Changes the value for a category option. The <code>catid</code> attribute indicates for which category the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v2.2] setMemberOption($memberid, $name, $value)</h3>

<p>Changes the value for a member option. The <code>memberid</code> attribute indicates for which member the option is valid. (other options: see <code>setOption</code>)</p>

<h3>[v3.2] setItemOption($itemid, $name, $value)</h3>

<p>Changes the value for an item option. The <code>itemid</code> attribute indicates for which item the option is valid. (other options: see <code>setOption</code>)</p>

<h3>getOption($name)</h3>

<p>Returns the value for an option in the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr></table>

<h3>[v2.2] getBlogOption($blogid, $name)</h3>

<p>Returns the value for a blog option. <code>blogid</code> indicates for which blog a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v2.2] getCategoryOption($catid, $name)</h3>

<p>Returns the value for a category option. <code>catid</code> indicates for which category a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v2.2] getMemberOption($memberid, $name)</h3>

<p>Returns the value for a member option. <code>memberid</code> indicates for which member a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>[v3.2] getItemOption($itemid, $name)</h3>

<p>Returns the value for an item option. <code>itemid</code> indicates for which item a value is requested (other parameters: see <code>getOption</code>)</p>

<h3>deleteOption($name)</h3>

<p>Deletes an option from the database</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr></table>

<h3>[v2.2] deleteBlogOption($name)</h3>

<p>Deletes a blog option (see <code>deleteOption</code>)</p>

<h3>[v2.2] deleteCategoryOption($name)</h3>

<p>Deletes a category option (see <code>deleteOption</code>)</p>

<h3>[v2.2] deleteMemberOption($name)</h3>

<p>Deletes a member option (see <code>deleteOption</code>)</p>

<h3>[v3.2] deleteItemOption($name)</h3>

<p>Deletes an item option (see <code>deleteOption</code>)</p>

<h3>[v2.2] getAllBlogOptions($name)</h3>

<p>Returns all values for a given blog option. The result is an associative array with a value for each existing blogid</p>

<h3>[v2.2] getAllCategoryOptions($name)</h3>

<p>Returns all values for a given category option. The result is an associative array with a value for each existing catid</p>

<h3>[v2.2] getAllMemberOptions($name)</h3>

<p>Returns all values for a given member option. The result is an associative array with a value for each existing memberid</p>

<h3>[v3.2] getAllItemOptions($name)</h3>

<p>Returns all values for a given item option. The result is an associative array with a value for each existing itemid</p>

<h3>[v3.2] getBlogOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each blogid ('id')</p>

<table><tr>
	<th>parameter</th>
	<th>value</th>
</tr><tr>
	<td>$name</td>
	<td>Option name</td>
</tr><tr>
	<td>$amount</td>
	<td>The amount of options you want</td>
</tr><tr>
	<td>$sort</td>
	<td>Sort ascending ('asc') or descending ('desc')</td>
</tr></table>

<h3>[v3.2] getMemberOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each memberid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<h3>[v3.2] getCategoryOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each categoryid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<h3>[v3.2] getItemOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>Returns the top of the values for a given option. The result is an array where every element is an array with a value ('value') for each itemid ('id') (parameters: see <code>getBlogOptionTop</code>)</p>

<div class="note">
<b>Note:</b> You can't call these functions from inside constructors of plugin classes. If you want to execute them when the plugin is loaded, place them in the <code>init()</code> method instead.
</div>

<h1>Database tables <a name="tables" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Access to Nucleus tables</h2>

<p>Up to v2.0, accessing the nucleus tables was just a matter of performing an SQL query on one of the <code>nucleus_</code> tables. Since it is possible to use a custom table name in Nucleus versions >2.0, some precautions are needed in plugin development:</p>

<ol>
	<li>Instead of using a fixed tablename like <code>nucleus_item</code>, use the global function <code>sql_table('item')</code> to generate the prefixed tablename</li>
	<li>Make sure your plugin returns <code>1</code> (<code>true</code>) when <code>supportsFeature('SqlTablePrefix')</code> is called on it. If it doesn't, you won't be able to load the plugin on Nucleus versions > 2.0 when a custom prefix has been set (as a precaution)</li>
</ol>

<p class="note">Note that the <code>sql_table</code> global function in not available in Nucleus versions up to v2.0. If you use this method and want your plugin to work on Nucleus versions &lt;= 2.0, add the following snippet of code on top of your plugin class:</p>

<pre class="example"><code>&lt;?php

// plugin needs to work on Nucleus versions &amp;=2.0 as well
if (!function_exists('sql_table'))
{
	function sql_table($name) {
		return 'nucleus_' . $name;
	}
}

class NP_HelloWorld extends NucleusPlugin {
...
}

?&gt;</code></pre>

<h2>Your own tables</h2>

<p>If your plugin needs database tables of it's own, you should create then in the <code>install</code> method and remove them in the <code>unInstall</code> method.</p>

<p>Some pointers</p>
<ul>
	<li>Consider using a table name like <code>nucleus_plug_<i>plugname</i></code> to avoid conflicts with other plugins. Generate them through <code>sql_table('plug_plugname')</code> to make it work with custom prefixes</li>
	<li>You don't need to make a database connection yourself. You can execute queries using the PHP command <code>mysql_query()</code></li>
	<li>If you do make a database connection yourself, make sure to restore the connection with the Nucleus database afterwards. You can do this by calling <code>sql_connect()</code> at the end of your function. It might also be good to do this from the constructor, to avoid reconnecting constantly. You could then save your link identifier in <code>$this->db</code> and pass that along with every query.</li>
	<li>Also redefine the <code>getTableList()</code> method to make sure your table gets backupped when using the backup function.</li>
</ul>



<h1>Plugin Admin Area <a name="admin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>As of Nucleus v2.5, plugins can create admin area pages that integrate with the Nucleus admin area. These pages can be accessed either from the plugin admin page, or the quickmenu on the left.</p>

<h2>Basics</h2>

<p>To provide an admin area, you'll need take these steps:</p>

<ol>
  <li>Create a subdirectory of the plugins directory, and name it <strong>pluginname</strong> if your plugin is <code>NP_PluginName</code>. Note that the name should be <strong>lowercase</strong>!</li>
  <li>
	In that directory, create a file called <strong>index.php</strong>, which looks like this:
	<pre><code>&lt;?php

	// if your 'plugin' directory is not in the default location,
	// edit this variable to point to your site directory
	// (where config.php is)
	$strRel = '../../../';

	include($strRel . 'config.php');
	if (!$member->isLoggedIn())
		doError('You\'re not logged in.');

	include($DIR_LIBS . 'PLUGINADMIN.php');

	// create the admin area page
	$oPluginAdmin = new PluginAdmin('<strong>PluginName</strong>');
	$oPluginAdmin->start();

	echo '&lt;h2&gt;Plugin Name&lt;/h2&gt;';

	echo '&lt;p&gt;<strong>Page contents here</strong>&lt;p&gt;';

	$oPluginAdmin->end();

?&gt;</code></pre>
  </li>
  <li>
	Subscribe to the <code>QuickMenu</code> event and add this code in your plugin:
	<pre><code>function event_QuickMenu(&amp;$data) {
		array_push(
			$data['options'],
			array(
				'title' => '<strong>Plugin Name</strong>',
				'url' => $this->getAdminURL(),
				'tooltip' => '<strong>Tooltip text</strong>'
			)
		);
	}</code></pre>
  </li>
  <li>
	Implement this method in your plugin:
	<pre><code>function hasAdminArea()
{
	return 1;
}</code></pre>
  </li>
</ol>

<h2>Considerations</h2>

<ul>
 <li>Don't just add an entry to the quick menu because it is possible. Imagine having 100 plugins installed, which all add an entry in the menu. This would result in a real mess. So, even if you add an entry in the menu, please consider adding an option (global or member-level) to enable/disable the quick menu entry.</li>
 <li>The <code>$strRel</code> variable in the <code>index.php</code> needs to be adapted manually if the plugins directory is not located in <code>nucleus/plugins/</code></li>
 <li>Make sure your admin area outputs <strong>valid XHTML</strong>. If not, the page will be broken in Gecko-based (Mozilla etc) browsers.</li>
</ul>

<h2>The PluginAdmin class</h2>

<p>The purpose of the <code>PluginAdmin</code> is to help you. Once created, you can use <code>$oPluginAdmin->plugin</code> to access the instance of your plugin.</p>

<h1>Plugin HelpPage <a name="help" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>As of Nucleus v3.2 plugins can provide a helppage with an overview of the plugins' functionality, the available skinvars and templatevars, where to get more info,...</p>

<p>The helppage will be accessible from the plugin overview in the admin area.</p>

<h2>Basics</h2>
<p>To provide a helppage, you'll need take these steps:</p>
<ol>
<li>Create a subdirectory of the plugins directory, and name it pluginname if your plugin is NP_PluginName. Note that the name should be lowercase! This is actually the same directory as for the <a href="#admin">admin area</a>.</li>
<li>In that directory, create a file called help.html. In this file you can document your plugin. This is a good template to start from:
<pre><code>&lt;h3&gt;Plugin overview&lt;/h3&gt;

&lt;p&gt;The only purpose of this plugin is to show how the plugin helppages work&lt;/p&gt;

&lt;h3&gt;Installation&lt;/h3&gt;

&lt;p&gt;If you can read this you correctly installed the plugin :-)&lt;/p&gt;

&lt;h3&gt;SkinVars&lt;/h3&gt;

&lt;p&gt;Because this plugin is only a testcase it doesn't has any skinvars/templatevars but suppose it would have:

&lt;ul&gt;&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1%&gt;&lt;/b&gt;: does something&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1(foobar)%&gt;&lt;/b&gt;: does something else&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;Support and Bug reports&lt;/h3&gt;

&lt;p&gt;For additional support and/or bug reports please use this forum thread:
&lt;a href="http://forum.nucleuscms.org/viewtopic.php?t=&lt;TOPIC_ID_GOES_HERE&gt;"&gt;
http://forum.nucleuscms.org/viewtopic.php?t=&lt;TOPIC_ID_GOES_HERE&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Version History&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;Version 0.1: initial testcaseversion&lt;/li&gt;
&lt;li&gt;Version 0.0: pre-initial version ;-)&lt;/li&gt;&lt;/ul&gt;</code></pre>
</li>
<li>Return a value larger than 0 for supportsFeature('HelpPage'):
<pre><code>function supportsFeature($what) {
	switch($what) {
	case 'HelpPage':
		return 1;
	  default:
		return 0;
	}
  }</code></pre>
</li>
</ol>

<h1>Plugin Dependency Check <a name="dependency" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Starting from 3.2, a new plugin interface is added to allow one to declare any dependency on other plugin(s). This is useful for any
plugin that requires another plugin to function. It is particularly useful for a plugin to detect broken dependencies that prevent if from functioning properly.</p>

<h2>How to write a plugin that utilize this function</h2>

<p>Let start from a real world example:</p>

<p>NP_PageLinkList depends on NP_BlogWithOffset to function, so we want to make sure if a user install NP_PageLinkList whithout first install
NP_BlogWithOffset. With this API, Nucleus offers a way for a plugin to detect any missing dependency before it is installed.</p>

<p>In this case, we want to code into NP_PageLinkList to mark that it requires NP_BlogWithOffset. When the plugin is installed, the core calls a
function in the plugin called <code>getPluginDep()</code>. This function returns a list of plugin it requires, and the core will check against all installed plugins and
refuse to install the plugin if a dependency is missing.</p>

<p>All we have to do is added this function to NP_PageLinkList:</p>

<pre><code>function getPluginDep() {
	 return array('NP_BlogWithOffset');
}</code></pre>

<p>The plugin dependency check also prevents plugins from being uninstalled if other plugins have a dependancy on it.</p>

</body>
</html>
