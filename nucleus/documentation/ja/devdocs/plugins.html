<!DOCTYPE html>
<html lang="ja">
<head>
	<!--
		Nucleus: PHP/MySQL Weblog CMS (http://nucleuscms.org/)
		Copyright (C) 2002-2013 The Nucleus Group

		This program is free software; you can redistribute it and/or
		modify it under the terms of the GNU General Public License
		as published by the Free Software Foundation; either version 2
		of the License, or (at your option) any later version.
		(see nucleus/documentation/index.html#license for more info)
	-->
    <meta charset="UTF-8" />
	<meta name="robots" content="noindex,noarchive,nofollow" />
    <link rel="index" href="./index.html" />
    <title>Nucleus - プラグイン API</title>
    <link rel="stylesheet" type="text/css" href="styles/manual.css" />
    <style type="text/css">
        /* refence parameters (greenish) */
        .ref {
            background-color: #c9f2d4;
            color: #444;
            padding-left:5px;
            letter-spacing:1px;
        }

        /* object parameters */
        .obj {
            color: #230bb7;
            font-style: italic;
            padding-left:5px;
            letter-spacing:1px;
        }
        .obj:after {
            content: " (object)";
        }

        /* read-only parameters (non-ref; reddish) */
        .ro {
            background-color: #ffddce;
            color: #444;
            padding-left:5px;
            letter-spacing:1px;
        }
        td ul {
            list-style-image:none;
            list-style-type:none;
            padding:0;
            margin:0;
        }
		.topleft { text-align: left; vertical-align: top; }
		.centermiddle { text-align: center; vertical-align: middle; }
		.plugin_description { text-align: left; }
		.plugin_description tr th:nth-of-type(1) { white-space: nowrap; }

    </style>
	<script src="../common.js" cache-control="max-age=15552000"></script>
</head>
<body>
	<div id="fontSizeChanger">
	<a href="#top" id="f_small">小</a>
	<a href="#top" id="f_medium">中</a>
	<a href="#top" id="f_large">大</a>
	</div>
<div id="body">

<div class="heading">
<a id="top" name="top">プラグイン API</a>
<em>2014年8月14日</em>
</div>

<div class="note-trans"><strong>訳者注：</strong>
    <ul>
        <li>このドキュメントの原文は以下のURLにあります。<br />
         <a href="http://nucleuscms.org/documentation/devdocs/plugins.html">http://nucleuscms.org/documentation/devdocs/plugins.html</a></li>
        <li>誤訳にお気づきの方は<a href="http://japan.nucleuscms.org/bb/viewforum.php?f=7">NucleusCMS日本語フォーラム</a>までご連絡いただけると助かります。</li>
    </ul>
</div>

<div class="note"><strong>注：</strong>
    <ul>
        <li>このドキュメントは基本的なプラグインの書き方についての情報を提供しています。さらに質問がある方は <a href="http://forum.nucleuscms.org/viewforum.php?f=10">Plugin
      Development Forum</a> （<a href="http://japan.nucleuscms.org/bb/viewforum.php?f=5">日本語フォーラム</a>）をご覧ください。</li>
        <li>Nucleusバージョン1.5以降に導入されたメソッドとイベントには、導入時のバージョン情報を付記しています。それらの機能を利用するときは、<code>getMinNucleusVersion</code> を適切に設定するのを忘れないでください。</li>
    </ul>
</div>

<h1>はじめに</h1>

<p>
<a href="./index.html">開発者向けドキュメントの目次へ戻る</a>
</p>

<p>
このドキュメントはNucleusプラグインの作り方についての解説です。
</p>

<h1><a id="toc" name="toc">目次</a></h1>

<ul>
    <li><a href="#introduction">イントロダクション</a></li>
    <li><a href="#firstplug">はじめてプラグインを書いてみる</a></li>
    <li><a href="#reserved_plugin_var">NucleusPlugin クラスのプロパティ(メンバ変数) 予約語一覧</a></li>
    <li><a href="#nucleusplugin"><code>NucleusPlugin</code> クラスの概要</a></li>
    <li><a href="#skinvars"><code>&lt;%plugin(...)%&gt;</code> スキン変数</a></li>
    <li><a href="#templatevars"><code>&lt;%plugin(...)%&gt;</code> テンプレート変数</a></li>
    <li><a href="#actions"><code>action.php</code> を使ったアクション</a></li>
    <li><a href="#events">イベントとイベント登録の仕方</a></li>
    <li><a href="#options">オプションを保存する</a></li>
    <li><a href="#tables">データベース・テーブル</a></li>
    <li><a href="#admin">プラグイン管理エリアの提供</a></li>
    <li><a href="#help">ヘルプページの提供</a></li>
    <li><a href="#dependency">プラグイン依存チェック</a></li>
	<li><a href="#internationalization">プラグインの国際化</a></li>
	<li><a href="#skinvar-formatting">スキン変数の出力の書式</a></li>
	<li><a href="#additional-reading">追記事項</a></li>
<!--    <li><a href="#parser">Using the <code>PARSER</code> class</a></li>
    <li><a href="#"></a></li>
    <li><a href="#"></a></li>
    <li><a href="#"></a></li>-->
</ul>

<h1>イントロダクション <a id="introduction" name="introduction" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleusプラグインによって、誰もがNucleusの提供する機能を、Nucleus内部のPHPコードを変更することなく拡張することができます。プラグインはあるメソッドを実装したシンプルなPHPスクリプトで、Nucleusユーザー同士で簡単に交換することができます。インストールは簡単で、プラグインディレクトリにファイルをアップし、Nucleusにそれを認識させるだけです。
</p>

<p>
プラグインの利点は以下のとおりです。
</p>

<ul>
    <li>実装について詳しくしらなくてもNucleusフレームワークに簡単に機能を追加できる</li>
    <li>必要なプラグインだけをインストールでき、ページ生成にかかる時間を節約できる</li>
</ul>

<p>
すべてのプラグインファイルは <code>config.php</code> に記述されたディレクトリに置く必要があります。
一般的に、それは <code>/your/path/nucleus/plugins/</code>  になるでしょう。
各プラグインは <code>/your/path/nucleus/plugins/NP_プラグイン名</code> に配置します。
プラグインファイル名は <code>NP<em>_name</em>.php</code> という形式を用いることにより認識されます。プラグインによっては、追加ファイルを格納する同名のサブディレクトリや、管理エリアを必要とします。
</p>

<div>プラグイン構成<br />
<table border="1" cellspacing="2" cellpadding="2" class="plugin_description">
<tbody>
	<tr>
		<th>プラグインの親フォルダ</th>
		<td><code>/your/path/nucleus/plugins/</code></td>
	</tr>
	<tr>
		<th>プラグインの個別フォルダ</th>
		<td><code>/your/path/nucleus/plugins/プラグイン名(小文字)</code></td>
	</tr>
	<tr>
		<th>プラグインのNP_プラグイン名.php</th>
		<td><code>/your/path/nucleus/plugins/プラグイン名(小文字)/NP_プラグイン名.php</code>
			<br />( - 3.70)
			<code>/your/path/nucleus/plugins/NP_プラグイン名.php</code></td>
	</tr>
	<tr>
		<th>プラグインの管理エリアファイル</th>
		<td><code>/your/path/nucleus/plugins/プラグイン名(小文字)/index.php</code></td>
	</tr>
</tbody>
</table>
</div>


<div class="note">
<strong>注：</strong> プラグイン名は大文字・小文字を識別しますので、<code>Np_</code> や <code>np_</code> ではなく、<code>NP_</code> で始まることに気をつけてください。またプラグインがサブディレクトリを使用する場合は、サブディレクトリの名称は<em>すべて小文字にします</em>。
</div>

<h1>NucleusPluginクラスのプロパティ(メンバ変数) 予約語一覧<a id="reserved_plugin_var" name="reserved_plugin_var" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>
<p>NucleusPluginクラスでは、以下のクラスプロパティ(PHPメンバ変数)が予約されています。派生先のクラスでは、定義・変更しないようにお願いします。<br />
また、プラグインのプロパティで plugin_で始まるものは、コア関数が将来使用するために予約されています。</p>
<div class="note">
<strong>注：</strong>予約語一覧: NucleusPluginクラス プロパティ<br />
_aOptionValues , _aOptionToInfo<br />
plugid , plugin_options<br />
(v3.80): plugin_admin_dir , plugin_admin_url , plugin_dir_type<br />
</div>


<h1>はじめてプラグインを書いてみる<a id="firstplug" name="firstplug" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
では、シンプルなプラグインを書いてみましょう。基本的にプラグインは、あらかじめ定義された <code>NucleusPlugin</code> クラスを継承したPHPクラスです。以下は<code>HelloWorld</code>プラグインの例です。
</p>

<pre class="example"><code>&lt;?php
class NP_HelloWorld extends NucleusPlugin
{
    public function getName()    { return 'Hello World'; } // プラグインの名前
    public function getVersion() { return '1.0'; }         // プラグインのバージョン
    public function getAuthor()  { return 'My name'; }     // プラグインの作者

    // プラグインのサイトURL mailto:foo@example.com の形式も可
    public function getURL()
    {
        return 'http://example.com/';
    }

    // インストール済みのプラグインリストに表示される説明文
    public function getDescription()
    {
        return 'これはテストプラグインです。';
    }

    public function doSkinVar($skinType)
    {
        echo 'Hello World!';
    }

    public function supportsFeature($feature)
    {
        return in_array($feature, array(
//            'SqlTablePrefix',  // v3.80で廃止
//            'SqlApi',          // v3.80で廃止
//            'HelpPage',
//            'pluginadmin',
//            'handleSpam',
            ));
    }

}
</code></pre>

<ol>
    <li>
        このコードをコピーし、 <code>NP_HelloWorld.php</code> と名づけて保存し、プラグインディレクトリに置きます。<em>最初の <code>&lt;?php</code> の前にスペースがないことを確認しましょう</em>。ところでNP は &quot;Nucleus Plugin&quot; って意味ですよ :-) 念のため。
    </li>
    <li>Nucleusの管理画面を開き、<em>Nucleusの管理＞プラグインの管理</em>にいきます。</li>
    <li><em>HelloWorld</em> プラグインがインストール可能な状態になっているはずですので、インストールします。すべてがうまくいけば、インストール済みプラグインリストに追加されます。</li>
    <li>
        あなたのスキンの１つを編集し、実際のページに表示する箇所に次の文を挿入します。
<pre class="example"><code>&lt;%HelloWorld%&gt;</code></pre>
        注意：カッコ内の名称 (<code>HelloWorld</code>) は大文字小文字を識別します！
    </li>
    <li>さて、編集したスキンから生成されるページを見てみましょう。プラグイン変数を追加した場所に &quot;Hello World&quot; と見えますね？</li>
</ol>

<p>
ここまではそれほど難しくなかったと思います。さらに読み進めて理解してください。
</p>







<h1>NucleusPlugin クラスの概要 <a id="nucleusplugin" name="nucleusplugin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>すべてのプラグインは、<code>NucleusPlugin</code> というPHPクラスを継承しなければなりません。難しそうに聞こえても心配ご無用、大丈夫です。このPHPクラスの継承によって、プラグインに必要なメソッドだけを実装でき、いくつかの補助ファンクションにアクセスでき、つまりはあなたの人生はよりラクになります。</p>

<p>下記は <code>NucleusPlugin</code> が提供する、再実装可能なメソッドの概要です。このクラス自身のソースコードを見たければ、<code>nucleus/libs/PLUGIN.php</code>にあります。</p>

<table summary="An overview of the redefinable methods in the class NucleusPlugin">
    <caption><code>NucleusPlugin</code> クラスの概要（再定義可能なメソッド）</caption>
    <tr>
        <th abbr="method">メソッド名</th><th abbr="desc">説明</th>
    </tr>
    <tr>
        <td><code>getName()</code></td>
        <td>プラグイン名を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>
    </tr>
    <tr>
        <td><code>getAuthor()</code></td>
        <td>プラグインの作者名を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>
    </tr>
    <tr>
        <td><code>getURL()</code></td>
        <td>プラグインをダウンロード可能な、またはプラグインの追加情報のあるサイトのURLを返します。そのようなサイトがない場合は作者のメールアドレスへの mailto:リンクが適切です。デフォルトの実装では <code>Undefined</code> を返すため、必ず再定義されないといけません。</td>
    </tr>
    <tr>
        <td><code>getDescription()</code></td>
        <td>プラグインに関する説明文（長文）を返します。インストール済みプラグインリストに表示されます。デフォルトの実装では <code>Undefined</code> を返します。</td>
    </tr>
    <tr>
        <td><code>getVersion()</code></td>
        <td>プラグインの現在のバージョンを返します。デフォルトは <code>0.0</code> を返します。</td>
    </tr>
    <tr>
        <td><code>getMinNucleusVersion()</code></td>
        <td>(v2.0b) 最低限必要なNucleusのバージョンを返します。デフォルトは <code>155</code> (v1.55)を返します。後に導入されたプラグイン関連機能を利用している場合は、このファンクションを実装するようお願いします（例： v2.0 =&gt; 200）。ただし、Nucleus v1.55 はこのファンクションを使用しないため、新機能を利用したプラグインが（対応する前のシステムに）インストールされる可能性が残っています。</td>
    </tr>
    <tr>
        <td><code>getMinNucleusPatchLevel()</code></td>
        <td>(v3.1) 最低限必要なNucleusのバージョン(<code>getMinNucleusVersion</code>)での、最低限必要なパッチレベルを返します。デフォルトは <code>0</code> を返します。このファンクションは主に新しいプラグインの機能がNucleusの最新版のパッチによって可能になる場合に用いられます。</td>
    </tr>
    <tr>
        <td><code>init()</code></td>
        <td>プラグインを初期化します。このメソッドはプラグインオブジェクトが生成された直後に呼び出され、<code>plugid</code>属性がセットされます。デフォルトではこのメソッドは何もしません。</td>
    </tr>
    <tr>
        <td><code>doSkinVar($skinType)</code></td>
        <td><code>&lt;%plugin(...)%&gt;</code> スキン変数によってプラグインが呼び出されたときにこのメソッドが呼ばれます。<code>$skinType</code> パラメータはプラグインが呼ばれた場所のスキンタイプに該当します（<code>item</code>, <code>archive</code>, ...）。パラメータが一つしかないことに混乱しないでください。複数パラメータを渡すことも<strong>可能</strong>です。<a href="#skinvars"><code>doSkinVar</code> メソッドの実装に関する詳細情報はこちら</a>。デフォルトではこのメソッドはなにも出力しません。</td>
    </tr>
    <tr>
        <td><code>doTemplateVar(&amp;$item)</code></td>
        <td>基本的に <code>doSkinVar</code> と同じですが、今度は<em>テンプレート</em>内（<code>item header/body/footer</code> と <code>dateheader/footer</code>）での<code>&lt;%plugin(...)%&gt;</code> 変数からの呼び出しになります。デフォルトではこのメソッドはテンプレートをスキンタイプとみなして<code>doSkinVar</code> メソッドに処理を渡します。<a href="#templatevars"><code>doTemplateVar</code> メソッドの実装に関する詳細情報はこちら</a></td>
    </tr>
    <tr>
        <td><code>doTemplateCommentsVar(&amp;$item, &amp;$comment)</code></td>
        <td>(v2.0b) 基本的に <code>doSkinVar</code> と同じですが、今度は<em>テンプレート</em>内（コメント部分）での<code>&lt;%plugin(...)%&gt;</code> 変数からの呼び出しになります。デフォルトではこのメソッドはテンプレートをスキンタイプとみなして<code>doSkinVar</code> メソッドに処理を渡します。<a href="#templatevars"><code>doTemplateCommentsVar</code>メソッドの実装に関する詳細情報はこちら</a></td>
    </tr>
    <tr>
        <td><code>doItemVar(&amp;$item, &amp;$param)</code></td>
        <td>(v3.30) 基本的に <code>doSkinVar</code> と同じですが、今度は<em>投稿した記事</em>内での<code>&lt;%plugin(...)%&gt;</code> 変数からの呼び出しになります。渡される引数のうち<code>&amp;$item</code>は変数が記述されているアイテムのフルオブジェクトを、<code>&amp;$param</code>はプラグインごとの関数のパラメータになります。</td>
    </tr>
    <tr>
        <td><code>doIf($key, $value)</code></td>
        <td>(v3.30) スキン変数 <code>if/ifnot/elseif/elseifnot</code> に対して、プラグイン独自の判断をすることができるメソッドです。通常は、<code>$key</code> 変数が <code>$value</code> の値を持っているかを調べて、 <code>true</code> か <code>false</code> を返すことになります。このメソッドをプラグインに実装する場合は、作者は使用方法のドキュメントを書くようにしてください。</td>
    </tr>
    <tr>
        <td><code>doAction($type)</code></td>
        <td>プラグインがユーザーインタラクションを求めたとき、 <code>action.php</code>を介してこのメソッドがそれを与えます。これはNucleus自身が新しいコメントや投票を処理するのに使用するスクリプトです。正しいパラメータを用いることで、プラグインからの <code>doAction</code> メソッドを呼び出せます。<code>$type</code> はオプションのメッセージタイプに該当します。<code>doAction</code> メソッド内で、リクエストからの追加の変数にアクセスできます。デフォルトではこのメソッドがエラーメッセージをトリガーすると<code>'No Such Action'</code>という文字列を返します。<a href="#actions"><code>doAction</code> に関する詳細情報はこちら</a></td>
    </tr>
    <tr>
        <td><code>install()</code></td>
        <td>このメソッドはプラグインがインストールされた際に呼ばれます。データベース・テーブルの生成やプラグインオプションの生成などの初期化作業を行うことができます。デフォルトではこのメソッドは何もしません。</td>
    </tr>
    <tr>
        <td><code>unInstall()</code></td>
        <td>プラグインがアンインストールされた際に呼ばれます。この時点でデータベースに作られたプラグイン情報を消去すると良いです。デフォルトではこのメソッドは何もしません。</td>
    </tr>
    <tr>
        <td><code>getEventList()</code></td>
        <td>(-v3.71)プラグインはイベント登録が可能です。イベントはNucleusが何かアクションを起こすたびに生成されます。たとえば、<code>AddItem</code> イベントは、このイベントを登録しているすべてのプラグインを呼び出します。呼び出されるメソッドは <code>event_AddItem($params)</code>になります。 <code>$params</code> パラメータは、例えば <code>AddItem</code>     の <code>itemid</code> のような、情報フィールドを複数持つ連想配列です。デフォルトではどのイベントにも登録されていないことを示す空の配列を返します。<a href="#events">イベントに関する詳細情報はこちら</a></td>
    </tr>
    <tr>
        <td><code>getTableList()</code></td>
        <td>このメソッドはプラグインが生成したデータベース・テーブルの配列を返します。これはNucleusが提供するバックアップ機能で利用されるので、プラグインテーブルをバックアップに含めることができます。デフォルトでは空の配列を返します。</td>
    </tr>
    <tr>
        <td><code>hasAdminArea()</code></td>
        <td>プラグインが独自の管理エリアをもつ場合 1 を、そうでない場合 0 を返します。デフォルトでは <code>0</code> を返します。</td>
    </tr>
    <tr>
        <td><code>getPluginDep()</code></td>
        <td>(v3.2) プラグイン名の配列を返します。Nucleusはこれらのプラグインが前もってインストールされてない場合、プラグインのインストールを拒否します。デフォルトでは空の配列が返されます。<a href="#dependency">プラグイン依存に関する詳細情報はこちら</a></td>
    </tr>
</table>

<p>実装可能なメソッドの次は、<code>NucleusPlugin</code> クラスが提供する、再実装<strong>すべきでない</strong>幾つかの特殊メソッドです。これらはプラグイン内で、<code>$this-&gt;functionName()</code>シンタックスを利用して呼び出します。</p>

<table summary="An overview of the auxiliary methods in the class NucleusPlugin. You should NOT redefine these">
    <caption><code>NucleusPlugin</code> クラスの概要（再定義不可能なメソッド）</caption>
    <tr>
        <th abbr="method">メソッド名</th><th abbr="desc">説明</th>
    </tr>
    <tr>
        <td>
            <ul>
                <li><code>createOption(...)</code></li>
                <li><code>createBlogOption(...)</code>(v2.2)</li>
                <li><code>createCategoryOption(...)</code>(v2.2)</li>
                <li><code>createMemberOption(...)</code>(v2.2)</li>
                <li><code>createItemOption(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">新しいオプションを生成します。</a></td>
    </tr>
    <tr>
        <td>
            <ul>
                <li><code>deleteOption(...)</code></li>
                <li><code>deleteBlogOption(...)</code>(v2.2)</li>
                <li><code>deleteCategoryOption(...)</code>(v2.2)</li>
                <li><code>deleteMemberOption(...)</code>(v2.2)</li>
                <li><code>deleteItemOption(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">オプションを削除します。</a></td>
    </tr>
    <tr>
        <td>
            <ul>
                <li><code>setOption(...)</code></li>
                <li><code>setBlogOption(...)</code>(v2.2)</li>
                <li><code>setCategoryOption(...)</code>(v2.2)</li>
                <li><code>setMemberOption(...)</code>(v2.2)</li>
                <li><code>setItemOption(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">オプションに値をセットします。</a></td>
    </tr>
    <tr>
        <td>
            <ul>
                <li><code>getOption(...)</code></li>
                <li><code>getBlogOption(...)</code>(v2.2)</li>
                <li><code>getCategoryOption(...)</code>(v2.2)</li>
                <li><code>getMemberOption(...)</code>(v2.2)</li>
                <li><code>getItemOption(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">オプションの値を取得します。</a></td>
    </tr>
    <tr>
        <td>
            <ul>
                <li><code>getAllBlogOptions(...)</code>(v2.2)</li>
                <li><code>getAllCategoryOptions(...)</code>(v2.2)</li>
                <li><code>getAllMemberOptions(...)</code>(v2.2)</li>
                <li><code>getAllItemOptions(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">与えられたオプションにより、すべての値（コンテクストごとの一つの値）の連想配列を返します。</a></td>
    </tr>

    <tr>
        <td>
            <ul>
                <li><code>getBlogOptionTop(...)</code>(v3.2)</li>
                <li><code>getMemberOptionTop(...)</code>(v3.2)</li>
                <li><code>getCategoryOptionTop(...)</code>(v3.2)</li>
                <li><code>getItemOptionTop(...)</code>(v3.2)</li>
            </ul>
        </td>
        <td><a href="#options" title="More info on options">与えられたオプションにより、すべての値のうちの最初の値を返します。</a></td>
    </tr>
    <tr>
        <td><code>getID()</code></td>
        <td>このプラグインのIDを返します（このIDはNucleus内部で利用されるものです）。</td>
    </tr>
    <tr>
        <td><code>getAdminURL()</code></td>
        <td>プラグインの管理エリアが置かれたURLを返します（そのような管理エリアがない場合は、この情報は無効です）。</td>
    </tr>
    <tr>
        <td><code>getDirectory()</code></td>
        <td>プラグインの追加ファイルが格納されたサーバーのファイルシステムのパスを返します（そのようなファイルがない場合は、この情報は無効です）。結果は&quot;<code>.../nucleus/plugins/<em>plugname</em>/</code>&quot;のようになります。</td>
    </tr>
    <tr>
        <td><code>getShortName()</code></td>
        <td>"NP_"部分を省き、全てを小文字にしたプラグインのクラス名を返します。この情報は <code>getAdminURL</code> と <code>getDirectory</code> で使用されます。</td>
    </tr>

</table>

<h1>スキン変数<a id="skinvars" name="skinvars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>解説</h2>

<p>
独自のスキン変数を生成し、プラグイン名がNP_PlugNameである場合、<code>&lt;%PlugName(parameters)%&gt;</code>として呼び出すことができます（すでに存在するスキン変数とかぶらない場合）。パラメータはカンマ区切りです。
</p>

<p>
スキン変数を扱うには、<code>doSkinVar</code> メソッドを実装する必要があります。いくつかの例を以下に示します。
</p>

<pre class="example"><code>function doSkinVar($skinType)
function doSkinVar($skinType, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1, $param2)
function doSkinVar($skinType, $skinVar, $param1 = 'default value')</code></pre>

<ul>
    <li><code>$skinType</code> パラメータは、'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup',  <a href="#templatevars" title="Information on templatevars">'template'</a>のうちの一つを取ります</li>
    <li><code>$skinVar</code> は、スキン変数のタイプとして解釈される実質的に最初のパラメータになります（例：<code>&lt;%plugin(PlugName,VarType)%&gt;</code>）。</li>
    <li><code>doSkinVar()</code>（パラメータ無し）を使い、PHPファンクションの<code>func_get_args()</code>を用いてパラメータを取得することができます。引数の数の異なる、タイプの違うスキン変数を扱うときに便利です。</li>
</ul>

<h2>ノート</h2>

<ul>
    <li>(v2.0b) グローバル変数としてパースされている <code>$currentSkinName</code> を使ってスキンの名前を取得できます。</li>
</ul>




<h1>テンプレート変数<a id="templatevars" name="templatevars" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>解説</h2>

<p>
テンプレートプラグイン変数はスキンプラグイン変数と同様に働きますが以下の2点が異なります。</p>

<ol>
    <li>スキン内ではなくテンプレート内から呼ばれます。</li>
    <li>$skinTypeパラメータを取りません。代わりに現在パースされているアイテムやコメントの情報付きの追加パラメータを取ります。
    <ul>
            <li><code>doTemplateVar</code> メソッドは <code>&amp;$item</code> パラメータを取ります。</li>
            <li><code>doTemplateCommentsVar</code> メソッドは <code>&amp;$item</code> と <code>&amp;$comment</code> パラメータを取ります。</li>
      </ul>
        <strong>&amp;マークに注意！</strong>
    </li>
</ol>

<p>テンプレート変数はスキン変数と同じ要領で呼ばれます（<code>&lt;%plugin(PlugName,parameters)%&gt;</code> または <code>&lt;%PlugName(parameters)%&gt;</code>）。
</p>

<p>
デフォルトでは、全てのテンプレート変数は'<code>template</code>'を<code>skintype</code>パラメータとして、<code>doSkinVar</code> メソッドに渡ります。
</p>

<p>
独自の実装を提供したい場合は、<code>doTemplateVar</code> メソッドや <code>doTemplateCommentsVar</code> メソッドを再定義する必要があります。<code>skintype</code>パラメータが無くなる以外はdoSkinVarと同様に働きます。
</p>

<pre class="example"><code>function doTemplateVar(&amp;$item)
function doTemplateVar(&amp;$item, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1, $param2)
function doTemplateVar(&amp;$item, $type, $param1 = 'default value')
function doTemplateCommentsVar(&amp;$item, &amp;$comment)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1, $param2)
function doTemplateCommentsVar(&amp;$item, &amp;$comment, $type, $param1 = 'default value')</code></pre>

<h2>ノート</h2>

<ul>
    <li>(v2.0b) グローバル変数として内部で利用される <code>$currentSkinName</code> を使ってテンプレートの名前を取得できます。</li>
</ul>




<h1>アクション<a id="actions" name="actions" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>プラグインは <code>action.php</code> を通してアクションを行うことができ、同様のスクリプトがコメントや投票の受け取りにも使用されてます。GETまたはPOSTのどちらかを通して呼び出せます。必要なパラメータは<code>action</code>（'plugin'と指定）、<code>name</code>（プラグイン名）、<code>type</code>（リクエストされたアクションの種類）です。</p>

<p>これらのアクションを有効にするために、<code>doAction($actionType)</code> メソッドをプラグイン内で実装する必要があります。リクエストからの追加パラメータは<code>requestVar('<em>name</em>')</code> で取得できます（<code>requestVar</code> はPHPが付加する magic_quotes_gpc に配慮しています）。</p>

<p>
<code>doAction</code> メソッドが文字列を返すとき、エラーとして解釈され、エラーメッセージが表示されます。
</p>






<h1>イベント<a id="events" name="events" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>
Nucleusプラグインはなにか重要なことが起きたときに発生するイベントに登録可能です。プラグインはイベント発生の際にアクションを実行したり、テキストを出力したりできます。
</p>

<h2>例</h2>

<p>
下記は <code>PreAddComment</code> イベント（blogにコメントが追加される直前に生成されるイベント）にプラグインが登録する例です。
</p>

<pre class="example"><code>class NP_Acronyms extends NucleusPlugin {
  ...
  function getEventList() { return array('PreAddComment'); } /* v3.80以降不要 */
  ...
  function event_PreAddComment(&amp;$data) {
    // 頭字語 HTML を置き換え
    $data['comment']['body'] =
        strreplace('HTML',
                   '&lt;acronym title="HyperText Markup Language"&gt;HTML&lt;/acronym&gt;',
                   $data['comment']['body']);
  }
}
</code></pre>

<p>このプラグインはコメント中の'HTML'というテキストを'<code>&lt;acronym title=&quot;HyperText Markup Language&quot;&gt;HTML&lt;/acronym&gt;</code>'に置き換えます。acronymタグはHTMLタグで、頭字語についての追加情報を提供します。</p>

<h2>イベント登録の仕方</h2>

<p>イベント登録に必要なステップは以下になります。</p>

<ol>
    <li><code>event_EventName($data)</code> という形でメソッドを生成し、この中でイベントを処理します。</li>
    <li>(-v3.71) <code>getEventList</code> メソッドから返る配列にイベント名を追加します。※v3.80以降はevent_関数名は自動抽出されますのでgetEventListメソッドを実装する必要はありません。</li>
</ol>

<p>複数のプラグインが同じイベントに登録できます。管理エリアのプラグインリストの順序に従ってプラグインに通知が行きます。リストの上にあるプラグインほど早く通知されます。</p>

<h2>パラメータ</h2>

<p><code>event_EventName</code> メソッドはひとつだけ <code>$data</code> パラメータを持ち、それはイベントごとに内容が異なります。これは連想配列です。この連想配列に渡されたオブジェクトや配列は<strong>参照形式</strong>で渡されるため、これらに加えた変更は記憶されます。</p>

<p>以下のイベントリストは、パラメータ変更がNucleusに知られるかどうかを示すために色を使い分けています。</p>

<ul>
    <li><var class="ref">参照渡し（緑）</var>: この種のパラメータに変更を加えるとNucleusに知られます。</li>
    <li><var class="ro">値渡し（赤）</var>: プラグインイベントハンドラに渡される前に値がコピーされます。これらの変数への変更は自動的に破棄されます。.</li>
</ul>

<p>パラメータとして渡されるオブジェクトは<var class="obj">object</var>.として示されます。ほとんどのオブジェクトは参照渡しで、<var class="obj ref">object by ref</var>のように示されます。</p>

<h2>イベントリスト</h2>

<table summary="An overview of events to which a Nucleus Plugin can subscribe, and what parameters are passed along to the method that handles the event">
    <caption>プラグインが登録できるイベント</caption>
    <tr>
        <th abbr="name">イベントの名前</th><th abbr="timing">イベントが発生するタイミング</th><th abbr="param">プラグインに渡されるパラメータ</th>
    </tr>
    <tr>
        <td>PreLoadMainLibs</td>
        <td>(v3.7) ログイン判定直後・コアファイル群読み込み直前</td>
        <td>なし</td>
    </tr>
    <tr>
        <td>InitSkinParse</td>
        <td>スキンの初期化の直前</td>
        <td><dl>
            <dt class="obj ref">skin</dt>
            <dd>パースする<code>SKIN</code>オブジェクト</dd>
            <dt class="ro">type</dt>
            <dd>スキンタイプ（'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser'のいずれか)</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreSkinParse</td>
        <td>スキンのパースの直前</td>
        <td><dl>
            <dt class="obj ref">skin</dt>
            <dd>パースする<code>SKIN</code>オブジェクト</dd>
            <dt class="ro">type</dt>
            <dd>スキンタイプ（'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser'のいずれか）</dd>
            <dt class="ref">contents</dt>
            <dd>スキンの内容</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostSkinParse</td>
        <td>スキンのパースの直後</td>
        <td><dl>
            <dt class="obj ref">skin</dt>
            <dd>パースする<code>SKIN</code>オブジェクト</dd>
            <dt class="ro">type</dt>
            <dd>スキンタイプ（'index', 'item', 'archive', 'archivelist', 'member', 'error', 'search', 'imagepopup', 'fileparser'のいずれか）</dd>
            <dt class="ref">output</dt>
            <dd>(v3.80,v3.70-ja)<br>ブラウザに出力する全てのテキスト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreItem</td>
        <td>アイテムのパース前、ただしアイテムヘッダーのパース後</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">item</dt>
            <dd>アイテムデータを持つオブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostItem</td>
        <td>アイテムのパース後、ただしアイテムフッターのパース前</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">item</dt>
            <dd>アイテムデータを持つオブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreComment</td>
        <td>コメントの表示前</td>
        <td><dl>
            <dt class="ref">comment</dt>
            <dd>コメントデータを持つ連想配列</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostComment</td>
        <td>コメントの表示後</td>
        <td><dl>
            <dt class="ref">comment</dt>
            <dd>コメントデータを持つ連想配列</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDateHead</td>
        <td>日付ヘッダーのパース前</td>
        <td><dl>
            <dt class="obj ref">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">timestamp</dt>
            <dd>日付ヘッダーのタイムスタンプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDateHead</td>
        <td>日付ヘッダーのパース後</td>
        <td><dl>
            <dt class="obj ref">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">timestamp</dt>
            <dd>日付ヘッダーのタイムスタンプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDateFoot</td>
        <td>日付フッターのパース前</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">timestamp</dt>
            <dd>日付フッターのタイムスタンプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDateFoot</td>
        <td>日付フッターのパース後</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">timestamp</dt>
            <dd>日付フッターのタイムスタンプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>LoginSuccess</td>
        <td>ログイン成功後</td>
        <td><dl>
            <dt class="obj ref">member</dt>
            <dd><code>MEMBER</code> オブジェクト</dd>
			<dt class="ro">username</dt>
			<dd>ログ印字に使用されたログイン名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>LoginFailed</td>
        <td>ログイン失敗後</td>
        <td><dl>
            <dt class="ro">username</dt>
            <dd>ログイン時に使われたユーザー名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>Logout</td>
        <td>ログアウト後</td>
        <td><dl>
            <dt class="ro">username</dt>
            <dd>ログアウト時のユーザー名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreBlogContent</td>
        <td>blogの内容がスキン変数を通して挿入される前</td>
        <td><dl>
            <dt class="obj ref">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">type</dt>
            <dd>呼び出されたスキン変数 ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostBlogContent</td>
        <td>blogの内容がスキン変数を通して挿入された後</td>
        <td><dl>
            <dt class="obj ref">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ro">type</dt>
            <dd>呼び出されたスキン変数 ('blog', 'otherblog', 'archive', 'archivelist', 'item', 'searchresults', 'othersearchresults', 'categorylist', 'otherarchive', 'otherarchivelist')</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddComment</td>
        <td>コメントがデータベースに追加される前</td>
        <td><dl>
            <dt class="ref">comment</dt>
            <dd>コメントデータ（連想配列）</dd>
            <dt class="ref">spamcheck</dt>
            <dd>(v3.3) <em>SpamCheck</em>イベントの結果として返されるデータ構造（連想配列）</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddComment</td>
        <td>コメントがデータベースに追加された後</td>
        <td><dl>
            <dt class="ref">comment</dt>
            <dd>コメントデータ（連想配列）</dd>
            <dt class="ref">commentid</dt>
            <dd>コメントのID</dd>
            <dt class="ref">spamcheck</dt>
            <dd>(v3.3) <em>SpamCheck</em>イベントの結果として返されるデータ構造（連想配列）</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostRegister</td>
        <td>新規ユーザーの登録後</td>
        <td><dl>
            <dt class="obj ref">member</dt>
            <dd>新しい<code>MEMBER</code> オブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddItem</td>
        <td>アイテムがデータベースに追加された後</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>データベースにできた新しい itemid</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostUpdateItem</td>
        <td>アイテムがデータベースにアップデートされた直後</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>アイテムのID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddItem</td>
        <td>アイテムがデータベースに追加される直前</td>
        <td><dl>
            <dt class="ref">title</dt>
            <dd>タイトル</dd>
            <dt class="ref">body</dt>
            <dd>本文</dd>
            <dt class="ref">more</dt>
            <dd>拡張テキスト</dd>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ref">authorid</dt>
            <dd>執筆者ID</dd>
            <dt class="ref">timestamp</dt>
            <dd>UNIX タイムスタンプ</dd>
            <dt class="ref">closed</dt>
            <dd>1 （コメント不可） or 0 （コメント可）</dd>
            <dt class="ref">draft</dt>
            <dd>1 （ドラフト） or 0 （非ドラフト）</dd>
            <dt class="ref">catid</dt>
            <dd>カテゴリーID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreUpdateItem</td>
        <td>データベースにあるアイテムが更新される直前</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>アイテム ID</dd>
            <dt class="ref">title</dt>
            <dd>タイトル</dd>
            <dt class="ref">body</dt>
            <dd>本文</dd>
            <dt class="ref">more</dt>
            <dd>拡張テキスト</dd>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG オブジェクト</code> object</dd>
            <dt class="ref">closed</dt>
            <dd>1 （コメント不可） or 0 （コメント可）</dd>
            <dt class="ref">catid</dt>
            <dd>カテゴリーID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PrepareItemForEdit</td>
        <td>アイテムをデータベースから取得した直後で、編集のためにユーザーに表示される前</td>
        <td><dl>
            <dt class="ref">item</dt>
            <dd>アイテムデータを持つ連想配列</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreUpdateComment</td>
        <td>コメントが更新され、データベースに保存される直前</td>
        <td><dl>
            <dt class="ref">body</dt>
            <dd>コメント本文</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PrepareCommentForEdit</td>
        <td>コメントをデータベースから取得した直後で、編集のためにユーザーに表示される前</td>
        <td><dl>
            <dt class="ref">comment</dt>
            <dd>コメントデータ（連想配列）</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PrePluginOptionsEdit</td>
        <td>
            <ul>
                <li>(v2.0b) 'プラグインオプションの編集'フォームが生成される前</li>
                <li>(v2.2) パラメータ追加</li>
                <li>(v3.2) 各オプションにパラメータ追加</li>
            </ul>
        </td>
        <td><dl>
            <dt class="ro">context</dt>
            <dd>(v2.2) <code>global</code>, <code>blog</code>, <code>member</code>, <code>item</code>, <code>category</code>のいずれか</dd>
            <dt class="ref">options</dt>
            <dd>次のインデックスをもつ連想配列： <code>name</code>, <code>value</code>, <code>oid</code>, <code>description</code>, <code>type</code>, <code>typeinfo</code>, <code>contextid</code>, <code>extra</code> 。追加オプションをここに加えることも可能（それらで何かの処理をするときはPostPluginOptionsUpdateの記述も必要）<br />
            <code>extra</code>フィールドを用いて、オプションに追加HTML（たとえばフォームのコントロール）を追加できます。もしそうする場合、 <code>extra</code> に追加する前に <code>pid</code> と <code>getID()</code> を比較し、さらに <code>name</code> をチェックすべきです。</dd>
            <dt class="ro">plugid</dt>
            <dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）（コンテクストがglobalのときのみ存在）</dd>
            <dt class="ro">contextid</dt>
            <dd>コンテクスト ID (blogid, memberid, catid, itemid コンテクストによる)</dd>

        </dl></td>
    </tr>
    <tr>
        <td>PrePluginOptionsUpdate</td>
        <td>
            (v3.2) プラグインオプションが更新される前。（このイベントを使ってオプションの新しい値を評価したり変更したりできます）
        </td>
        <td><dl>
            <dt class="ro">context</dt>
            <dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code>, <code>category</code>のいずれか</dd>
            <dt class="ro">plugid</dt>
            <dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）</dd>
            <dt class="ro">optionname</dt>
            <dd>オプション名</dd>
            <dt class="ro">contextid</dt>
            <dd>コンテクスト ID (blogid, memberid, catid, itemid コンテクストによる)</dd>
            <dt class="ref">value</dt>
            <dd>そのオプションの新しい値</dd>
        </dl></td>

    </tr>

    <tr>
        <td>PostPluginOptionsUpdate</td>
        <td>
            <ul>
                <li>(v2.0b) プラグインオプションの更新後</li>
                <li>(v2.2) コンテクストによって異なるパラメータ</li>
            </ul>
        </td>
        <td><dl>
            <dt class="ro">context</dt>
            <dd>(v2.2) <code>global</code>, <code>member</code>, <code>blog</code>, <code>item</code>, <code>category</code>のいずれか</dd>
            <dt class="ro">plugid</dt>
            <dd>プラグイン ID （これが気になるなら、<code>GetID()</code>を見ると理解できる）（globalコンテクスト）</dd>
            <dt class="ro">blogid</dt>
            <dd>(v2.2) blog ID (blog コンテクスト)</dd>
            <dt class="ref obj">blog</dt>
            <dd>(v2.2) BLOG オブジェクト (blog コンテクスト)</dd>
            <dt class="ro">memberid</dt>
            <dd>(v2.2) member ID (member コンテクスト)</dd>
            <dt class="ref obj">member</dt>
            <dd>(v2.2) MEMBER オブジェクト (member コンテクスト)</dd>
            <dt class="ro">catid</dt>
            <dd>(v2.2) category ID (category コンテクスト)</dd>
            <dt class="ro">itemid</dt>
            <dd>(v2.2) item ID (item コンテクスト)</dd>
            <dt class="ref obj">member</dt>
            <dd>(v2.2) ITEM オブジェクト (item コンテクスト)</dd>
        </dl></td>

    </tr>
    <tr>
        <td>PostAuthentication</td>
        <td>(v2.0b) ログイン処理の完了後。ページリクエストごとに発生</td>
        <td><dl>
            <dt class="ro">loggedIn</dt>
            <dd><code>$member-&gt;isLoggedIn()</code>の戻り値</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddItemForm</td>
        <td>(v2.0b) アイテム追加フォーム（ブックマークレットまたは管理エリア）が生成される直前</td>
        <td><dl>
            <dt class="ref">contents</dt>
            <dd>連想配列への参照。そのうちの'title', 'body', 'more'にはフォームフィールドへの初期値を与えることができます。複数のプラグイン間でこれらの値の変更を避けるには、処理後に'hasBeenSet'の値を1にセットします（かつ処理前にこの値をチェックするようにします）</dd>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>AddItemFormExtras</td>
        <td>(v2.0b) アイテム追加ページまたはブックマークレット内部のどこか。<code>template</code> ファイルの類を別に用意しなくても、ここでプラグインがカスタムフィールドを追加できる。</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>EditItemFormExtras</td>
        <td>
            (v2.0b) アイテム編集ページまたはブックマークレット内部のどこか。<code>template</code> ファイルの類を別に用意しなくても、ここでプラグインがカスタムフィールドを追加できる。<br style="margin-bottom:1.5em;" />

            あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
<pre class="example"><code>&lt;h3&gt;プラグイン名&lt;/h3&gt;
&lt;p&gt;追加フォームの内容&lt;/p&gt;</code></pre>
        このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。
        </td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクトへの参照</dd>
            <dt class="ro">variables</dt>
            <dd>
                (read-only) 編集されるアイテムに関する全ての情報を持つ連想配列： 'itemid', 'draft', 'closed', 'title', 'body', 'more', 'author', 'authorid', 'timestamp', 'karmapos', 'karmaneg', 'catid'
            </dd>
            <dt class="ro">itemid</dt>
            <dd>アイテム IDへのショートカット</dd>
        </dl></td>
    </tr>
    <tr>
        <td>BlogSettingsFormExtras</td>
        <td>(v2.0) blog設定ページにフォームを追加可能
            <br style="margin-bottom:1.5em;" />
            あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
<pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容
&lt;/p&gt;&lt;/form&gt;</code></pre>
            このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。

        </td>
        <td><dl>
            <dt class="obj ref">blog</dt>
            <dd><code>BLOG</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteItem</td>
        <td>(v2.0) アイテムがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>削除されるアイテムID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteItem</td>
        <td>(v2.0) アイテムがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>削除されたアイテムID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteCategory</td>
        <td>(v2.0) カテゴリーがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">catid</dt>
            <dd>削除されるカテゴリー ID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteCategory</td>
        <td>(v2.0) カテゴリーがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">catid</dt>
            <dd>削除されたカテゴリー ID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteBlog</td>
        <td>(v2.0) blogがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">blogid</dt>
            <dd>削除されるblogID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteBlog</td>
        <td>(v2.0) blogがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">blogid</dt>
            <dd>削除されたblogID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteMember</td>
        <td>(v2.0) メンバーがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ref obj">member</dt>
            <dd><code>削除されるメンバーに関するMEMBER</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteMember</td>
        <td>(v2.0) メンバーがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ref obj">member</dt>
            <dd><code>削除されるメンバーに関するMEMBER</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteTeamMember</td>
        <td>(v2.0) メンバーがweblogチームから削除される直前</td>
        <td><dl>
            <dt class="ref obj">member</dt>
            <dd><code>MEMBER</code> オブジェクトへの参照</dd>
            <dt class="ro">blogid</dt>
            <dd>blogID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteTeamMember</td>
        <td>(v2.0) メンバーがweblogチームから削除された直後</td>
        <td><dl>
            <dt class="ref obj">member</dt>
            <dd><code>MEMBER</code> オブジェクトへの参照</dd>
            <dt class="ro">blogid</dt>
            <dd>blogID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteComment</td>
        <td>(v2.0) コメントがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">commentid</dt>
            <dd>削除されるコメントID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteComment</td>
        <td>(v2.0) コメントがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">commentid</dt>
            <dd>削除されたコメントID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>ActionLogCleared</td>
        <td>(v2.0) アクションログが消去された後</td>
        <td>なし</td>
    </tr>
    <tr>
        <td>PreDeleteTemplate</td>
        <td>(v2.0) テンプレートがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">templateid</dt>
            <dd>削除されるテンプレートID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteTemplate</td>
        <td>(v2.0) テンプレートがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">templateid</dt>
            <dd>削除されたテンプレートID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteSkin</td>
        <td>(v2.0) スキンがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">skinid</dt>
            <dd>削除されるスキンID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteSkin</td>
        <td>(v2.0) スキンがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">skinid</dt>
            <dd>削除されたスキンID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteSkinPart</td>
        <td>スペシャルスキンパーツがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">skinid</dt>
            <dd>削除されるスペシャルスキンパーツが含まれるスキンのID</dd>
            <dt class="ro">skintype</dt>
            <dd>削除されるスペシャルスキンパーツの名前</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteSkinPart</td>
        <td>スペシャルスキンパーツがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">skinid</dt>
            <dd>削除されたスペシャルスキンパーツが含まれるスキンのID</dd>
            <dt class="ro">skintype</dt>
            <dd>削除されたスペシャルスキンパーツの名前</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeletePlugin</td>
        <td>(v2.0) プラグインがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">plugid</dt>
            <dd>削除されるプラグインID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeletePlugin</td>
        <td>(v2.0) プラグインがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">plugid</dt>
            <dd>削除されたプラグインID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreDeleteBan</td>
        <td>(v2.0) 禁止IPがデータベースから削除される直前</td>
        <td><dl>
            <dt class="ro">blogid</dt>
            <dd>禁止IPが削除されるblogのID</dd>
            <dt class="ro">iprange</dt>
            <dd>禁止されたIPレンジ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostDeleteBan</td>
        <td>(v2.0) 禁止IPがデータベースから削除された直後</td>
        <td><dl>
            <dt class="ro">blogid</dt>
            <dd>禁止IPが削除されたblogのID</dd>
            <dt class="ro">iprange</dt>
            <dd>禁止されたIPレンジ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddCategory</td>
        <td>(v2.0) 新しいカテゴリーがデータベースに生成される直前</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクトの参照</dd>
            <dt class="ref">name</dt>
            <dd>新しいカテゴリー名</dd>
            <dt class="ref">description</dt>
            <dd>新しいカテゴリーの説明</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddCategory</td>
        <td>(v2.0) 新しいカテゴリーがデータベースに生成された直後</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクトへの参照</dd>
            <dt class="ro">name</dt>
            <dd>新しいカテゴリー名</dd>
            <dt class="ro">description</dt>
            <dd>新しいカテゴリーの説明</dd>
            <dt class="ro">catid</dt>
            <dd>新しいカテゴリー ID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddBlog</td>
        <td>(v2.0) 新しいblogが生成される直前</td>
        <td><dl>
            <dt class="ref">name</dt>
            <dd>新しい blog名</dd>
            <dt class="ref">shortname</dt>
            <dd>新しい blogの短縮名</dd>
            <dt class="ref">timeoffset</dt>
            <dd>新しい blogのタイムオフセット</dd>
            <dt class="ref">description</dt>
            <dd>新しい blogの説明</dd>
            <dt class="ref">defaultskin</dt>
            <dd>新しいblogのデフォルトスキンのID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddBlog</td>
        <td>(v2.0) 新しいblogが生成された直後</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd>新しい<code>BLOG</code> オブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddPlugin</td>
        <td>(v2.0) プラグインが追加される直前</td>
        <td><dl>
            <dt class="ref">file</dt>
            <dd>新しいプラグインのファイル名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddPlugin</td>
        <td>(v2.0) プラグインが追加された直後</td>
        <td><dl>
            <dt class="ref obj">plugin</dt>
            <dd>新しく追加されたプラグインのオブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostUpdatePlugin</td>
        <td>(v3.80) 登録リストの更新を完了した直後<br />
            <br />
            プラグイン管理：登録リストのアップデートを押した直後に発生します。<br />
        </td>
        <td>なし</td>
    </tr>
    <tr>
        <td>PreAddTeamMember</td>
        <td>(v2.0) メンバーがblogチームに追加される直前</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">member</dt>
            <dd><code>MEMBER</code> オブジェクト</dd>
            <dt class="ref">admin</dt>
            <dd>新しく追加されたメンバーが管理権限を持っているかどうかを示すブール値</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddTeamMember</td>
        <td>(v2.0) メンバーがblogチームに追加された直後</td>
        <td><dl>
            <dt class="ref obj">blog</dt>
            <dd><code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">member</dt>
            <dd><code>MEMBER</code> オブジェクト</dd>
            <dt class="ro">admin</dt>
            <dd>新しく追加されたメンバーが管理権限を持っているかどうかを示すブール値</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddTemplate</td>
        <td>(v2.0) 新しいテンプレートが生成される直前（注：テンプレートが複製されたときも呼ばれる）</td>
        <td><dl>
            <dt class="ref">name</dt>
            <dd>新しいテンプレート名</dd>
            <dt class="ref">description</dt>
            <dd>新しいテンプレートの説明</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddTemplate</td>
        <td>(v2.0) 新しいテンプレートが生成された直後</td>
        <td><dl>
            <dt class="ro">name</dt>
            <dd>新しいテンプレート名</dd>
            <dt class="ro">description</dt>
            <dd>新しいテンプレートの説明</dd>
            <dt class="ro">templateid</dt>
            <dd>新しいテンプレートID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddSkin</td>
        <td>(v2.0) 新しいスキンが生成される直前（注：スキンが複製されたときも呼ばれる）</td>
        <td><dl>
            <dt class="ref">name</dt>
            <dd>新しいスキン名</dd>
            <dt class="ref">description</dt>
            <dd>新しいスキン名の説明</dd>
            <dt class="ref">type</dt>
            <dd>スキンのコンテントタイプ</dd>
            <dt class="ref">includeMode</dt>
            <dd>新しいスキンのインクルードモード</dd>
            <dt class="ref">includePrefix</dt>
            <dd>新しいスキンのインクルードプレフィックス</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddSkin</td>
        <td>(v2.0) 新しいスキンが生成された直後</td>
        <td><dl>
            <dt class="ro">name</dt>
            <dd>新しいスキン名</dd>
            <dt class="ro">description</dt>
            <dd>新しいスキンの説明</dd>
            <dt class="ro">type</dt>
            <dd>スキンのコンテントタイプ</dd>
            <dt class="ro">includeMode</dt>
            <dd>新しいスキンのインクルードモード</dd>
            <dt class="ro">includePrefix</dt>
            <dd>新しいスキンのインクルードプレフィックス</dd>
            <dt class="ro">skinid</dt>
            <dd>新しいスキンID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreAddBan</td>
        <td>(v2.0) 新しい禁止IPが追加される直前</td>
        <td><dl>
            <dt class="ref">blogid</dt>
            <dd>blogID</dd>
            <dt class="ref">iprange</dt>
            <dd>禁止されたIPレンジ</dd>
            <dt class="ref">reason</dt>
            <dd>禁止された理由を記述したテキストメッセージ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostAddBan</td>
        <td>(v2.0) 新しい禁止IPが追加された直後</td>
        <td><dl>
            <dt class="ro">blogid</dt>
            <dd>blogID</dd>
            <dt class="ro">iprange</dt>
            <dd>禁止されたIPレンジ</dd>
            <dt class="ro">reason</dt>
            <dd>禁止された理由を記述したテキストメッセージ</dd>
        </dl></td>
    </tr>

    <tr>
        <td>PreMoveItem</td>
        <td>(v2.0) アイテムが他のblog/カテゴリーに移される直前</td>
        <td><dl>
            <dt class="ref">itemid</dt>
            <dd>アイテムID</dd>
            <dt class="ref">destblogid</dt>
            <dd>移動先のblogID</dd>
            <dt class="ref">destcatid</dt>
            <dd>移動先のカテゴリーID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostMoveItem</td>
        <td>(v2.0) アイテムが他のblog/カテゴリーに移された直後</td>
        <td><dl>
            <dt class="ro">itemid</dt>
            <dd>アイテムID</dd>
            <dt class="ro">destblogid</dt>
            <dd>新しいblogID</dd>
            <dt class="ro">destcatid</dt>
            <dd>新しいカテゴリーID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreMoveCategory</td>
        <td>(v2.0) カテゴリーが他のblogに移される直前</td>
        <td><dl>
            <dt class="ref">catid</dt>
            <dd>カテゴリーID</dd>
            <dt class="ref obj">sourceblog</dt>
            <dd>移動元の<code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">destblog</dt>
            <dd>移動先の<code>BLOG</code> オブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostMoveCategory</td>
        <td>(v2.0) カテゴリーが他のblogに移された直後</td>
        <td><dl>
            <dt class="ro">catid</dt>
            <dd>カテゴリーID</dd>
            <dt class="ref obj">sourceblog</dt>
            <dd>移動元の<code>BLOG</code> オブジェクト</dd>
            <dt class="ref obj">destblog</dt>
            <dd>移動先の<code>BLOG</code> オブジェクト</dd>
        </dl></td>
    </tr>
    <tr>
        <td>MemberSettingsFormExtras</td>
        <td><span style="display:block;margin-bottom:1.5em;">(v2.0) メンバー設定ページにフォームを追加可能</span>
            あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
<pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容
&lt;/p&gt;&lt;/form&gt;</code></pre>
            このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。

        </td>
        <td><dl>
            <dt class="ref obj">member</dt>
            <dd><code>MEMBER</code> オブジェクトへの参照</dd>
        </dl></td>
    </tr>
    <tr>
        <td>GeneralSettingsFormExtras</td>
        <td><span style="display:block;margin-bottom:1.5em;">(v2.0) 一般設定ページにフォームを追加可能</span>
            あまり多くのデータを追加しないこと。また以下のように<strong>正しいXHTML</strong>を生成してください。
<pre class="example"><code>&lt;h4&gt;プラグイン名&lt;/h4&gt;
&lt;form method="post" action="..."&gt;&lt;p&gt;
追加フォームの内容
&lt;/p&gt;&lt;/form&gt;</code></pre>
            このようにして、正しい構造を保ちつつ複数のプラグインがオプションを保持できます。またフィールド名の重複を避けるためにプレフィックスを用いてください（例 <code>plug_tb_url</code>）。

        </td>
        <td>なし</td>
    </tr>
    <tr>
        <td>AdminPrePageHead</td>
        <td>(v2.5) 管理画面で、ページヘッドを出力する直前。このイベントはヘッド領域にスクリプトやCSSを追加するのに用いられます。</td>
        <td><dl>
            <dt class="ref">extrahead</dt>
            <dd>HTMLページのヘッド領域に埋め込まれる追加情報。ここに追加したいものを入れてください。</dd>
            <dt class="ro">action</dt>
            <dd>現在実行されているアクション、またはページタイプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>AdminPrePageFoot</td>
        <td>(v2.5) 管理画面で、ページフッターを出力する直前。</td>
      <td><dl>
            <dt class="ro">action</dt>
            <dd>現在実行されているアクション、またはページタイプ</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreSendContentType</td>
        <td>(v2.5) HTTPヘッダーにコンテントタイプがセットされる直前</td>
        <td><dl>
            <dt class="ref">contentType</dt>
            <dd>コンテントタイプ（<code>application/xhtml+xml</code>など）</dd>
            <dt class="ref">charset</dt>
            <dd>キャラクターセット</dd>
            <dt class="ro">pageType</dt>
            <dd>表示するページの種類を示す文字列：<code>skin</code> (スキンタイプ), <code>media</code> (メディアライブラリ), <code>admin-<em>action</em></code> (管理エリア), <code>bookmarklet-<em>action</em></code> (ブックマークレット)</dd>
        </dl></td>
    </tr>
    <tr>
        <td>QuickMenu</td>
        <td>(v2.5) 管理エリアのクイックメニューの一番下。そこへのプラグイン登録に利用されます。登録するにはoptionsに連想配列を入れます。実装例が<a href="#admin">プラグイン管理エリアを作る</a>のセクションにあります。</td>
        <td><dl>
            <dt class="ref">options</dt>
            <dd>配列</dd>
        </dl></td>
    </tr>
    <tr>
        <td>BookmarkletExtraHead</td>
        <td>(v2.5) ブックマークレット XHTMLコードのヘッド領域内。</td>
        <td><dl>
            <dt class="ref">extrahead</dt>
            <dd>XHTMLコードのヘッド領域に埋め込まれる追加情報。ここに追加したいものを入れてください。</dd>
        </dl></td>
    </tr>
    <tr>
        <td>FormExtra</td>
        <td>(v3.2) このイベントは、プラグインがコメント、メンバー間メール、認証フォームのいずれかのフォーム内に追加フィールドを挿入するときに使います。フォーム処理の際に発生する <code>ValidateForm</code> イベントに対応します。</td>
        <td><dl>
            <dt class="ro">type</dt>
            <dd>イベントを発生させるフォームタイプ
                <ul>
                    <li><code>activation</code></li>
                    <li><code>additemform</code> （注：これは管理画面のアイテム追加フォームではない）</li>
                    <li><code>commentform-loggedin</code></li>
                    <li><code>commentform-notloggedin</code></li>
                    <li><code>membermailform-loggedin</code></li>
                    <li><code>membermailform-notloggedin</code></li>
                </ul>
            </dd>
            <dt class="ro obj">member</dt>
            <dd><code>type</code> が <code>activation</code>のとき、このフィールドは認証メンバーの詳細情報を含みます</dd>
        </dl></td>
    </tr>
    <tr>
        <td>ValidateForm</td>
        <td>(v3.2) コメント、メンバー間メール、アカウント認証のいずれかが処理されるときに呼ばれます。プラグインはこれで各データの評価を実行でき、もし不具合があれば処理を中断できます。<code>FormExtra</code> と共に使うとフォームにフィールドを追加できます。</td>
        <td><dl>
            <dt class="ro">type</dt>
            <dd>処理されるフォームタイプ
                <ul>
                    <li><code>membermail</code></li>
                    <li><code>comment</code></li>
                    <li><code>activation</code></li>
                </ul>
            </dd>
            <dt class="ref">error</dt>
            <dd>フォーム処理をストップするときに、<code>error</code> フィールドに空でないエラーメッセージを記入します。このエラーメッセージはユーザー側に表示されます。</dd>
            <dt class="ref">comment</dt>
            <dd>コメントデータの連想配列（コメントフォームのときのみ）</dd>
            <dt class="ref">spamcheck</dt>
            <dd>(v3.3) <em>SpamCheck</em>イベントの結果として返される連想配列（コメントフォームのときのみ）</dd>
            <dt class="ro obj">member</dt>
            <dd>認証フォームのとき、認証中のメンバー情報を含みます。</dd>
        </dl></td>
    </tr>
    <tr>
        <td>ParseURL</td>
        <td>(v3.22)NucleusのコアでURLからアイテムやカテゴリのIDを読み取る前。プラグインはこのイベントを使ってURLを解釈します</td>
        <td><dl>
            <dt class="ro">type</dt>
            <dd>FancyURLの仮想ディレクトリ(拡張子無しファイル)のファイル名(item, blog, ...)</dd>
            <dt class="ro">info</dt>
            <dd>解決される前のURL(この名前は以前の変数名である<code>pathinfo</code>から来ています).</dd>
            <dt class="ref">complete</dt>
            <dd>プラグインがURLを解釈し終わるとこれが<strong>true</strong>にセットされます。<strong>false</strong>の場合はプラグインはURLを解釈していません。</dd>
        </dl></td>
    </tr>
    <tr>
        <td>GenerateURL</td>
        <td>(v3.22)URLが自動生成される前。このイベントを使って独自のURLを生成することができます。</td>
        <td><dl>
            <dt class="ro">type</dt>
            <dd>生成するURLのタイプ(item, blog, ...)</dd>
            <dt class="ro">params</dt>
            <dd>生成するURLに付加するパラメータ</dd>
            <dt class="ref">completed</dt>
            <dd>プラグインはURLを生成し終わるとこれを<strong>true</strong>にセットしてURLを返します。<strong>false</strong>の場合はプラグインはURLを生成していません。</dd>
            <dt class="ref">url</dt>
            <dd>プラグインが生成したURLを格納するための空の変数</dd>
        </dl></td>
    </tr>
    <tr>
        <td>SpamCheck</td>
        <td>(v3.3) 新しいコメントが追加されるときに呼ばれます。アンチスパムのプラグインはこのイベントを使ってコメントがスパムかどうかマークを付けられます。<code>SpamCheck</code>イベントの詳しい説明は別の文書を参照のこと（<a href='http://wakka.xiffy.nl/spamcheck_api'>SpamCheck API 2.0</a>）</td>
        <td><dl>
            <dt class="ref">spamcheck</dt>
            <dd>spamcheckのデータ構造（連想配列）</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PreMediaUpload</td>
        <td>(v3.3)アップロードされたファイルが｢media｣ディレクトリに書き込まれる前。</td>
        <td><dl>
            <dt class="ref">collection</dt>
            <dd>アップロードされたファイルが格納されるべき｢コレクション｣</dd>
            <dt class="ro">uploadfile</dt>
            <dd>テンポラリディレクトリに仮置きされているアップロードされたファイルのファイル名</dd>
            <dt class="ref">filename</dt>
            <dd>最終的に保存されるファイル名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>PostMediaUpload</td>
        <td>(v3.3)アップロードされたファイルが｢media｣ディレクトリに書き込まれた後。</td>
        <td><dl>
            <dt class="ro">collection</dt>
            <dd>アップロードされたファイルが格納された｢コレクション｣</dd>
            <dt class="ro">mediadir</dt>
            <dd>アップロードされたファイルが保存されたメディアディレクトリ</dd>
            <dt class="ro">filename</dt>
            <dd>保存されたファイル名</dd>
        </dl></td>
    </tr>
    <tr>
        <td>SendPing</td>
        <td>(v3.3)｢ブログの設定｣で｢更新時にweblogsアップデート通知サービスへPingを送りますか？｣が｢はい｣に設定されている時に限り、新しいアイテムを追加した時に呼び出されます(このイベントに対応しているプラグインがインストールされている時に限る)。このイベントはPing送信プラグインで各種｢ブログ検索サービス｣へ更新pingを送信します(例えば<a href="http://blogsearch.google.co.jp/">Googleブログ検索</a>など)</td>
        <td><dl>
            <dt class="ref">blogid</dt>
            <dd>アイテムが追加されたブログのID</dd>
        </dl></td>
    </tr>
    <tr>
        <td>JustPosted</td>
        <td>(v3.3)投稿された未来の日付のアイテムの設定時刻が来た時。このイベントはページの表示が完了した後に発生条件をチェックします。</td>
        <td><dl>
            <dt class="ref">blogid</dt>
            <dd>未来の日付のアイテムの設定時刻が来たブログのID</dd>
        </dl></td>
    </tr>
	<tr>
		<td>RegistrationFormExtraFields</td>
		<td>(v3.40) createaccount.php からビジターに表示されるアカウント作成フォームが表示され、FormExtra イベントが起きる前。プラグインはこのイベントによって、アカウント作成フォームに独自のフィールドを付け加えることができます。PostRegister イベントに同時に登録すると、付け加えたフィールドの値を評価することができる様になります。渡されるパラメータは、付け加えられたフィールドを、元々のフィールドと違和感無く表示させるために使用されます。このイベントの使用例はNP_Profileプラグインを参照してください。</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>アカウント作成フォームのタイプ。通常は <code>createaccount.php</code>。</dd>
			<dt class="ro">prelabel</dt>
			<dd>追加フィールドの｢ラベル｣の<strong>前に</strong>挿入される HTML コード</dd>
			<dt class="ro">postlabel</dt>
			<dd>追加フィールドの｢ラベル｣の<strong>後に</strong>挿入される HTML コード</dd>
			<dt class="ro">prefield</dt>
			<dd>追加フィールドの｢入力フィールド｣の<strong>前に</strong>挿入される HTML コード</dd>
			<dt class="ro">postfield</dt>
			<dd>追加フィールドの｢入力フィールド｣の<strong>後に</strong>挿入される HTML コード</dd>
		</dl></td>
	</tr>
	<tr>
		<td>TemplateExtraFields</td>
		<td>(v3.40) テンプレートが編集・更新される時。プラグイン製作者がコアのテンプレートシステムをより使いやすくするために、テンプレートにフィールドを追加することができます。プラグイン作者は追加するテンプレートフィールドの初期状態をプラグインオプションに保存し、そこで使用するテンプレート変数についてのドキュメントを書くことが要求されます。また、このイベントに関するサンプルプラグインが、フォーラムの<a href="http://japan.nucleuscms.org/bb/viewtopic.php?p=24401#24401" title="Sample">新API「TemplateExtraFields」を使ったプラグインの見本</a>(本家フォーラムのスレッドは <a href="http://forum.nucleuscms.org/viewtopic.php?p=87672#87672" title="Sample">Skin specific values for Plugins</a>)にあります。</td>
		<td><dl>
			<dt class="ref">fields</dt>
			<dd>プラグイン名をキーにした連想配列。配列の内容は、テンプレートのフィールド名をキーにした連想配列で、その値はフォームのフィールドに表示されるラベル。フィールド名は全て英数小文字で、フィールド名の重複を避けるためにプラグイン名を含んでいることが好ましい。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreArchiveListItem</td>
		<td>(v3.40) アーカイブリストが表示される前。アーカイブリストを表示するために使われたテンプレートのアーカイブリスト本体フィールドのテンプレート変数を追加／修正することを可能にします。追加のテンプレート変数についてのドキュメントも整備すべきです。</td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>テンプレート変数をキーにした連想配列。値はテンプレート変数に置き換えられる内容。この配列にキーと値のペアを追加することで、新しい変数が追加できます。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreCategoryListItem</td>
		<td>(v3.40) カテゴリーリストが表示される前。カテゴリーリストを表示するために使われたテンプレートのカテゴリーリスト本体フィールドのテンプレート変数を追加／修正することを可能にします。追加のテンプレート変数についてのドキュメントも整備すべきです。</td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>テンプレート変数をキーにした連想配列。値はテンプレート変数に置き換えられる内容。この配列にキーと値のペアを追加することで、新しい変数が追加できます。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreBlogListItem</td>
		<td>(v3.40) ブログリストが表示される前。ブログリストを表示するために使われたテンプレートのブログリスト本体フィールドのテンプレート変数を追加／修正することを可能にします。追加のテンプレート変数についてのドキュメントも整備すべきです。</td>
		<td><dl>
			<dt class="ref">listitem</dt>
			<dd>テンプレート変数をキーにした連想配列。値はテンプレート変数に置き換えられる内容。この配列にキーと値のペアを追加することで、新しい変数が追加できます。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PreTemplateRead</td>
		<td>(v3.40) テンプレートが読み込まれる直前。読み込むテンプレートを変更することができます。NP_MultiLanguage はこのイベントを使用しています。</td>
		<td><dl>
			<dt class="ref">name</dt>
			<dd>呼び出されるテンプレートの名前</dd>
		</dl></td>
	</tr>
	<tr>
		<td>CustomLogin</td>
		<td>(v3.40) Nucleus にログインする直前。ログインの手順をカスタマイズできます。外部認証を簡素化し、ログイン ID にメールアドレス等を使用できる様になります。</td>
		<td><dl>
			<dt class="ref">login</dt>
			<dd>ユーザーが｢ログインID｣フィールドに入力した文字列。Nucleus のメンバーとして登録されているなら、プラグイン側で外部認証された｢ログインID｣と Nucleus のそれを紐つけるべきです。そうでないとクッキーがセットされず、ページを移動するごとにログアウトしてしまいます。</dd>
			<dt class="ref">password</dt>
			<dd>ユーザーが｢パスワード｣フィールドに入力した文字列。</dd>
			<dt class="ref">success</dt>
			<dd>認証が成功したかどうかのフラグ。｢1｣が成功。失敗だと｢0｣。初期値は｢0｣。プラグイン側でセットします。</dd>
			<dt class="ref">allowlocal</dt>
			<dd>整数値。プラグイン側で外部認証に失敗した後に、Nucleus のログインを試すかどうかのフラグ。｢1｣が試す｢0｣が試さない。初期値は｢1｣プラグイン側でセットします。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PrePasswordSet</td>
		<td>(v3.50)パスワードを設定する時に呼び出されます。パスワードの強度をプラグインで設定することができます。</td>
		<td><dl>
			<dt class="ro">password</dt>
			<dd>ユーザーが入力したパスワード文字列</dd>
			<dt class="ref">errormessage</dt>
			<dd>エラーメッセージ。エラーが起きない場合は空白に設定します。</dd>
			<dt class="ref">valid</dt>
			<dd>設定しようとしているパスワードが妥当かどうかのフラグ。デフォルトは｢真｣。プラグインはこの値の妥当性を審査するべきです。</dd>
		</dl></td>
	</tr>
	<tr>
		<td>PostParseURL</td>
		<td>(v3.60) URLが完全にパースされた後( globalfunctions の ParseURL による)。selector() が実行されたりpath関連のglobal変数に何かがセットされる前にglobal変数を調整するのに便利。</td>
		<td><dl>
			<dt class="ro">type</dt>
			<dd>生成するURLのタイプ(item, blog, ...)</dd>
			<dt class="ro">info</dt>
			<dd>解決される前のURL(この名前は以前の変数名である<code>pathinfo</code>から来ています).</dd>
		</dl></td>
	</tr>

	<tr>
		<td>MediaUploadFormExtras</td>
		<td>(v3.60) Nucleusメディアマネージャのファイルアップロードページにフィールドを追加します。すべての出力が正しいXHTML 1.0 でなければなりません。PreMediaUpload イベントに同時に登録し、requestVar()を使って追加したフィールドから値を得ます。</td>
		<td>データは渡されません。</td>
	</tr>
<!--
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><dl>
            <dt></dt>
            <dd></dd>
        </dl></td>
    </tr> -->
</table>



<h1>オプションを保存する<a id="options" name="options" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>プラグインに簡単にオプションを登録・取得できるように一連のメソッドが用意されています。これらのオプションは直接Nucleusの管理エリアで編集でき、プラグイン自身の管理エリアを用意する必要もなく、PHPファイルそのものの中にオプションの値を書き込まずにすみます。</p>

<p>オプションは異なったコンテクストで利用可能です。</p>

<ol>
    <li><strong>グローバルオプション</strong>：管理エリアのプラグインセクションで編集可能</li>
    <li><strong>blogオプション</strong>：blog設定ページで編集可能</li>
    <li><strong>カテゴリーオプション</strong>：blog設定ページ（のカテゴリー編集ページ）で編集可能</li>
    <li><strong>メンバーオプション</strong>：メンバー編集ページで編集可能</li>
    <li><strong>アイテムオプション</strong>：アイテムの追加、およびアイテムの編集ページで編集可能</li>
</ol>

<h2>オプションの種類</h2>

<p>オプションにはいくつかのタイプが提供されています。</p>

<dl>
    <dt>text</dt>
    <dd>シンプルなテキスト</dd>
    <dt>yesno</dt>
    <dd>'yes'か'no'どちらか（編集画面ではラジオボタンとして表示されます）</dd>
    <dt>password</dt>
    <dd>テキストフィールド (編集画面では伏字で表示されます)</dd>
    <dt>textarea (v2.2)</dt>
    <dd>複数行のテキストフィールド</dd>
    <dt>select (v2.2)</dt>
    <dd>ドロップダウンメニュー。次のような形式の追加情報が必要です： Option 1|value1|Option 2|value2|Option 3|value3
    </dd>
</dl>

<h2>オプション・メタ</h2>

<p>Nucleus v3.2よりオプション・メタデータを用いて、オプションタイプを正しい値を受け取れるように制限できるようになりました。このメタデータは <code>$typeExtras</code>フィールドにセミコロン区切りのリストで保存されます。注：selectオプションでは、selectリストは<code>$typeExtras</code>のなかで一番最初でなければいけません。</p>

<table summary="メタデータ"><tr>
    <th abbr="key">キー</th>
    <th abbr="desc">説明</th>
</tr><tr>
    <td><code>datatype</code></td>
    <td>Nucleus本体に、どのデータ型を使いたいかという追加情報を与えます。現在は '<code>numerical</code>' のみ利用できます。 '<code>numerical</code>' を指定することでNucleusは数値情報のみを受け付けます（クライアントサイド・サーバサイド両方でチェック） （'<code>select</code>' と '<code>text</code>'のオプションタイプで利用できます）</td>
</tr><tr>
    <td><code>access</code></td>
    <td>'<code>readonly</code>'にセットすることで、オプションを編集不可能にします（'<code>text</code>' と '<code>textarea</code>'のオプションタイプで利用できます）<br />
    '<code>hidden</code>'を使うと、利用者側にそのオプションの存在を完全に隠蔽します（'<code>text</code>'のオプションタイプで利用できます）</td>
</tr></table>

<p>設定例</p>
<pre class="example"><code>// 数値のみを受け付けるテキストオプションを作成
$this-&gt;createBlogOption('FooBar', 'foobar', 'text', '0', 'datatype=numerical');
// 数値のみを受け付けるセレクトオプションを作成
$this-&gt;createItemOption('FooBar', 'foobar', 'select', '0', '0|0|1|1|2|2;datatype=numerical');
// 編集不可能なテキストエリアオプションを作成
$this-&gt;createOption('FooBar', 'foobar', 'textarea', 'This textarea is readonly', 'access=readonly');
</code></pre>

<h2>制限</h2>

<ol>
    <li>オプション名は最大20文字です。</li>
    <li>オプションの説明文は最大255文字です。</li>
    <li>オプションの値は制限ありません（v2.2より前のバージョンでは128文字の制限がありました）</li>
    <li>'=', '|', ';' のキャラクターはセレクトオプション用のセレクトリストやオプション・メタデータ中で使用することはできません。</li>
</ol>

<h2>メソッド</h2>

<h3>createOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>グローバル</strong>なコンテクストで新しいオプションを生成します。</p>

<table summary="createOption"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr><tr>
    <td>$desc</td>
    <td>オプション編集画面で表示される説明文</td>
</tr><tr>
    <td>$type</td>
    <td>オプションタイプ（前出）</td>
</tr><tr>
    <td>$defValue</td>
    <td>初期値</td>
</tr><tr>
    <td>$typeExtras</td>
    <td>オプションタイプの追加情報（前出）</td>
</tr></table>

<h3>[v2.2] createBlogOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>blog</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v2.2] createCategoryOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>カテゴリー</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v2.2] createMemberOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>メンバー</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v3.2] createItemOption($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>アイテム</strong>のコンテクストで新しいオプションを生成します（<code>createOption</code>を参照）。</p>

<h3>[v3.80] updateOptionDesc($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>グローバル</strong>なコンテクストで、更新または新しいオプションを生成します。</p>

<table summary="updateOptionDesc"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr><tr>
    <td>$desc</td>
    <td>オプション編集画面で表示される説明文</td>
</tr><tr>
    <td>$type</td>
    <td>オプションタイプ（前出）</td>
</tr><tr>
    <td>$defValue</td>
    <td>初期値</td>
</tr><tr>
    <td>$typeExtras</td>
    <td>オプションタイプの追加情報（前出）</td>
</tr></table>

<h3>[v3.80]  updateBlogOptionDesc($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>blog</strong>のコンテクストで、更新または新しいオプションを生成します。（<code>updateOptionDesc</code>を参照）。</p>

<h3>[v3.80]  updateCategoryOptionDesc($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>カテゴリー</strong>のコンテクストで、更新または新しいオプションを生成します。（<code>updateOptionDesc</code>を参照）。</p>

<h3>[v3.80]  updateMemberOptionDesc($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>メンバー</strong>のコンテクストで、更新または新しいオプションを生成します。（<code>updateOptionDesc</code>を参照）。</p>

<h3>[v3.80]  updateItemOptionDesc($name, $desc, $type, $defValue = '', $typeExtras = '')</h3>

<p><strong>アイテム</strong>のコンテクストで、更新または新しいオプションを生成します。（<code>updateOptionDesc</code>を参照）。</p>

<h3>setOption($name, $value)</h3>

<p>すでにデータベースに存在するオプションの値を変更します。</p>

<table summary="setOption"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr><tr>
    <td>$value</td>
    <td>新しい値</td>
</tr></table>

<h3>[v2.2] setBlogOption($blogid, $name, $value)</h3>

<p>blogオプションの値を変更します。<code>blogid</code>属性はどのblogでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v2.2] setCategoryOption($catid, $name, $value)</h3>

<p>カテゴリーオプションの値を変更します。<code>catid</code>属性はどのカテゴリーでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v2.2] setMemberOption($memberid, $name, $value)</h3>

<p>メンバーオプションの値を変更します。<code>memberid</code>属性はどのメンバーでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>[v3.2] setItemOption($itemid, $name, $value)</h3>

<p>アイテムオプションの値を変更します。<code>itemid</code>属性はどのアイテムでそのオプションが有効かを示します（その他のオプション：<code>setOption</code>を参照）。</p>

<h3>getOption($name)</h3>

<p>データベース内のオプションの値を返します。</p>

<table summary="getOption"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr></table>

<h3>[v2.2] getBlogOption($blogid, $name)</h3>

<p>blogオプションの値を返します。<code>blogid</code>属性は値がリスエストされたblogを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>[v2.2] getCategoryOption($catid, $name)</h3>

<p>カテゴリーオプションの値を返します。<code>catid</code>属性は値がリスエストされたカテゴリーを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>[v2.2] getMemberOption($memberid, $name)</h3>

<p>メンバーオプションの値を返します。<code>memberid</code>属性は値がリスエストされたメンバーを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>[v3.2] getItemOption($itemid, $name)</h3>

<p>アイテムオプションの値を返します。<code>itemid</code>属性は値がリスエストされたアイテムを示します（その他のオプション：<code>getOption</code>を参照）。</p>

<h3>deleteOption($name)</h3>

<p>データベースからオプションを削除します。</p>

<table summary="deleteOption"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr></table>

<h3>[v2.2] deleteBlogOption($name)</h3>

<p>blogオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] deleteCategoryOption($name)</h3>

<p>カテゴリーオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] deleteMemberOption($name)</h3>

<p>メンバーオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v3.2] deleteItemOption($name)</h3>

<p>アイテムオプションを削除します（<code>deleteOption</code>を参照）。</p>

<h3>[v2.2] getAllBlogOptions($name)</h3>

<p>与えられたblogオプションの全ての値を返します。結果は存在するblogidごとの連想配列です。</p>

<h3>[v2.2] getAllCategoryOptions($name)</h3>

<p>与えられたカテゴリーオプションの全ての値を返します。結果は存在するcatidごとの連想配列です。</p>

<h3>[v2.2] getAllMemberOptions($name)</h3>

<p>与えられたメンバーオプションの全ての値を返します。結果は存在するmemberidごとの連想配列です。</p>

<h3>[v3.2] getAllItemOptions($name)</h3>

<p>与えられたアイテムオプションの全ての値を返します。結果は存在するitemidごとの連想配列です。</p>

<h3>[v3.2] getBlogOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのblogid ('id') の値 ('value') を持つ配列になっています。</p>

<table summary="getOption"><tr>
    <th abbr="param">パラメータ</th>
    <th abbr="value">値</th>
</tr><tr>
    <td>$name</td>
    <td>オプション名</td>
</tr><tr>
    <td>$amount</td>
    <td>必要なオプション数</td>
</tr><tr>
    <td>$sort</td>
    <td>昇順 ('asc') か降順 ('desc') で並べ替え</td>
</tr></table>

<h3>[v3.2] getMemberOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのメンバーID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>

<h3>[v3.2] getCategoryOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのカテゴリーID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>

<h3>[v3.2] getItemOptionTop($name, $amount = 10, $sort = 'desc')</h3>

<p>与えられたオプションの最初の値を返します。結果は配列で、各要素がそれぞれのアイテムID ('id') の値 ('value') を持つ配列になっています（パラメータは<code>getBlogOptionTop</code>を参照）。</p>

<h3>[v3.80] existOptionDesc($name)</h3>

<p><strong>グローバル</strong>なコンテクストでオプションが定義されているか調べます。</p>

<table summary="existOptionDesc">
	<tr>
		<th abbr="param">パラメータ</th>
		<th abbr="value">値</th>
	</tr>
	<tr>
		<td>$name</td>
		<td>オプション名</td>
	</tr>
</table>

<h3>[v3.80] existBlogOptionDesc($name)</h3>

<p><strong>blog</strong>のコンテクストでオプションが定義されているか調べます。（<code>existOptionDesc</code>を参照）。</p>

<h3>[v3.80] existCategoryOptionDesc($name)</h3>

<p><strong>カテゴリー</strong>のコンテクストでオプションが定義されているか調べます。（<code>existOptionDesc</code>を参照）。</p>

<h3>[v3.80] existItemOptionDesc($name)</h3>

<p><strong>アイテム</strong>のコンテクストでオプションが定義されているか調べます。（<code>existOptionDesc</code>を参照）。</p>

<h3>[v3.80] existMemberOptionDesc($name)</h3>

<p><strong>メンバー</strong>のコンテクストでオプションが定義されているか調べます。（<code>existOptionDesc</code>を参照）。</p>

<div class="note">
<strong>注：</strong> プラグインクラス内のコンストラクタから、これらのファンクションを呼ぶことはできません。プラグインがロードされた後にこれらを実行したいときは、かわりに<code>init()</code>メソッド内に置きます。
</div>

<h1>データベース・テーブル<a id="tables" name="tables" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>Nucleusテーブルへのアクセス</h2>

<p>sql_table('テーブル名')の他に、3.80から parseQuery関数を通して、[@prefix@]が利用できるようになりました。
	<code>$sql = sprintf('SELECT ... FROM `%s` ...', sql_table('テーブル名'));</code><br />
	<code>$sql = parseQuery('SELECT ... FROM `[@prefix@]テーブル名` ...');</code>
</p>



<p>v3.5でNucleusはPDO等MySQL以外のデータベースハンドラのサポートをするようになりました。この機能はベータ実装ではありますが、プラグイン開発者はデータベースの呼び出しに使用する関数の「sql_*」への書き換えを始めてください。
基本的に、使用している全ての「mysql_*」関数を「sql_*」に置き換える必要があります。たとえば<code>mysql_fetch_assoc($result)</code>は<code>sql_fetch_assoc($result)</code> に置き換えになります。
全ての関数を書き換えたら、Sql APIが無い古いバージョンのNucleusインストールできないように、次に示すコードをプラグイン内に記述して、インストールに必要な最低バージョンを350に指定する必要があります。<br /></p>
<pre class="example"><code>function getMinNucleusVersion() { return '350'; }</code></pre>

<ol>
    <li>カスタム・テーブル名を利用できるため、注意が必要です。<code>nucleus_item</code> などの固定されたテーブル名の代わりに、テーブル名のプレフィックスを生成するために <code>sql_table('item') </code>というグローバルファンクションを利用します。</li>
    <li>(v2.0 - 3.71まで) : <code>supportsFeature('SqlTablePrefix')</code> が呼ばれたときにプラグインが1（真）を返すようにします。これがないと、カスタムプレフィックスがセットされている場合でバージョンが2.0から3.71までのNucleusではプラグインをロードできません（用心のため）。<br />
        sql_table関数の十分な周知期間(14年以上)が経過したため、v3.80以降は不要になり、プラグインのロード時にsupportsFeature('SqlTablePrefix')のチェックは行いません。</li>
    <li>v3.5以降:<code>supportsFeature('SqlApi')</code> が呼ばれたときにプラグインが1（真）を返すようにします。3.5以降のバージョンでは、データベースのバックエンドにmysqlでないものを使用している場合にプラグインをロードできなくなります（用心のため）。</li>
    <li>v3.5以降: pdoドライバ使用時は、「mysql_*」関数は使えません。「sql_*」関数を使用してください。</li>
<!--
    <li>v4.0以降:「mysql_*」関数は使えません。「sql_*」関数を使用してください。</li>
-->
</ol>
<div class="note">
<strong>注：</strong> DELETE, INSERT, UPDATE 文　以外で sql_num_rowsを使用している場合は 置き換えてください。
</div>

<h2>独自テーブル</h2>

<p>もしプラグイン独自のテーブルが必要なら、<code>install</code>メソッドの中で独自テーブルを生成し、<code>unInstall</code>メソッドの中でそれを削除するようにします。</p>

<p>いくつかの注意点</p>
<ul>
    <li><code>nucleus_plug_<em>plugname</em></code> のように、他のプラグインと競合しないテーブル名を考えてください。カスタムプレフィックスに対応するため、テーブル名を<code>sql_table('plug_plugname')</code> で生成してください。</li>
    <li>自分自身でデータベース接続をする必要はありません。PHPコマンド <code>mysql_query()</code> のラッパーであるNucleus関数 <code>sql_query()</code> を使ってSQL命令を実行できます。</li>
    <li>自分でデータベース接続をする場合、後でNucleusデータベースへの接続を復元するようにしてください。自前処理の後で <code>sql_connect()</code>  を呼ぶことで可能です。頻繁な再接続を避けるために、コンストラクタでそれを行うのも良いです。<code>$this- &gt;db</code>のリンクIDを保持でき、各クエリにそれを渡すことができます。</li>
    <li>バックアップ機能を使う時は、独自テーブルもバックアップに含めるよう、<code>getTableList()</code> を再定義してください。</li>
	<li>ユーザーがプラグインをアップデートする時や、何らかの理由で一時的にプラグインをアンインストールしなければならない時、やプラグイン独自のテーブルの内容が失われることがあります。そうならないように、テーブルを削除するか否かをプラグインオプションで設定できるようにしておくといいでしょう。テーブルの削除をオプションでコントロールするには、install()メソッドで次のようなオプションを作成します。
	<pre class="example"><code>$this-&gt;createOption('del_uninstall', 'Delete NP_MyPlugin data tables on uninstall?', 'yesno','no');</code></pre>
	そしてuninstall()メソッドで、次のようにします。
	<pre class="example"><code>if ($this-&gt;getOption('del_uninstall') == 'yes')	{
	foreach ($this-&gt;getTableList() as $table) {
		sql_query("DROP TABLE $table");
	}
}</code></pre></li>
</ul>



<h1>プラグイン管理エリア<a id="admin" name="admin" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>管理エリアに統合されたプラグイン管理エリアを作成できます。これらのページは従来のプラグイン管理ページや左側のクイックメニューからアクセスできます。</p>

<h2>基本</h2>

<p>管理エリアを提供するには、次のステップが必要です。</p>

<ol>
  <li>プラグインディレクトリに<strong>プラグイン名</strong>のサブディレクトリを作ります。たとえばプラグイン名が<code>NP_PluginName</code>なら、'pluginname'です。ディレクトリ名はすべて小文字で！</li>
  <li>
    そのディレクトリで、次のような<strong>index.php</strong>を用意します。
    <pre><code>&lt;?php

    // if your 'plugin' directory is not in the default location,
    // edit this variable to point to your site directory
    // (where config.php is)
    $p = explode(DIRECTORY_SEPARATOR, dirname(__FILE__));
    while($p && array_pop($p) && !empty($p)) {
        $strRel = implode(DIRECTORY_SEPARATOR, $p) . DIRECTORY_SEPARATOR;
        if (@is_file($strRel . 'config.php')) {
            break;
        }
    }
    if (@!is_file($strRel . 'config.php'))
        exit('Error: config file not found.');

    include($strRel . 'config.php');
    if (!$member-&gt;isLoggedIn())
        doError('You\'re not logged in.');

    include($DIR_LIBS . 'PLUGINADMIN.php');

    // create the admin area page
    $oPluginAdmin = new PluginAdmin('<strong>PluginName</strong>');
    $oPluginAdmin-&gt;start();

    echo '&lt;h2&gt;プラグイン名&lt;/h2&gt;';

    echo '&lt;p&gt;<strong>ページ内容</strong>&lt;p&gt;';

    $oPluginAdmin-&gt;end();

?&gt;</code></pre>
  </li>
  <li>
    プラグイン側に次のコードを挿入し、クイックメニューイベントに登録します。
    <pre><code>function event_QuickMenu(&amp;$data) {
        array_push(
            $data['options'],
            array(
                'title'   =&gt; '<strong>プラグイン名</strong>',
                'url'     =&gt; $this-&gt;getAdminURL(),
                'tooltip' =&gt; '<strong>ツールチップテキスト</strong>'
            )
        );
    }</code></pre>
  </li>
  <li>
    プラグイン側に次の関数を記述します。
    <pre><code>function hasAdminArea()
{
    return 1;
}</code></pre>
  </li>
  <li> オプション。クイックメニュー登録のオプションを作成し、誰に表示するか制限します。<code>quickmenu</code>という<code>yesno</code>タイプのオプションがinstall()にあるとします。次のように、クイックメニュー登録の表示を最高管理者とブログ管理者に制限します。
	<pre class="example"><code>function event_QuickMenu(&amp;$data) {
    // only show when option enabled
    if ($this-&gt;getOption('quickmenu') != 'yes') return;
    global $member;
    if (!$member-&gt;isAdmin() &amp;&amp; !count($member-&gt;getAdminBlogs())) return;
    array_push($data['options'],
      	array('title' =&gt; 'PluginName',
       	'url' =&gt; $this-&gt;getAdminURL(),
       	'tooltip' =&gt; 'Administer NP_PluginName'));
}</code></pre>
  </li>
</ol>

<h2>考慮すること</h2>

<ul>
 <li>登録できるからといって安易にクイックメニューへ登録しないこと。クイックメニューにプラグインが100個並んだりしたらかなりウンザリするでしょう。ですので、クイックメニューに登録する場合でも、クイックメニュー登録を有効・無効化するプラグインオプションを（グローバルまたはメンバーオプションで）用意することを考えてください。</li>
 <li><code>プラグインディレクトリが nucleus/plugins/ ではない場合は、サンプルを参考に plugins/config-plugin.php を作ります。 また古いプラグインの場合index.php内の $strRel</code> 変数を手動で書き換える必要があります。サンプルではディレクトリをたどり最初に見つかったconfig.phpを読み込みます。</li>
 <li>管理エリアのアウトプットが<strong>正しいXHTML</strong>になっているか確認してください。正しくないと、MozillaなどのGeckoベースのブラウザでページ表示が崩れます。</li>
</ul>

<h2>PluginAdmin クラス</h2>

<p><code>PluginAdmin</code> クラスは助けになります。これを一度生成すれば、<code>$oPluginAdmin-&gt;plugin</code> でプラグインのインスタンスにアクセスできます。</p>

<h1>プラグイン用ヘルプページ <a id="help" name="help" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>Nucleus v3.2から、プラグインの機能の概要、利用できるスキン・テンプレート変数、さらに詳細な情報のありかなどを示すヘルプページを提供可能になりました。</p>

<p>ヘルプページは管理画面のプラグイン一覧からアクセス可能になります。</p>

<h2>基本</h2>
<p>ヘルプページを提供するために、次のステップが必要です。</p>
<ol>
<li>プラグインディレクトリに、プラグイン名をつけたサブディレクトリを作成します。ディレクトリ名は小文字であることに注意します。<a href="#admin">管理エリア</a>を作るときと同様です。</li>
<li>そのディレクトリの中に help.html を作り、プラグインについての文章を記述します。次の雛型からはじめると良いでしょう。
<pre><code>&lt;h3&gt;プラグインの概要&lt;/h3&gt;

&lt;p&gt;このプラグインはヘルプページがいかに機能するかを示すためだけのものです&lt;/p&gt;

&lt;h3&gt;インストール&lt;/h3&gt;

&lt;p&gt;これを読めてるならインストールは正しくできてます :-)&lt;/p&gt;

&lt;h3&gt;スキン変数&lt;/h3&gt;

&lt;p&gt;このプラグインはただのテストケースなのでスキン・テンプレート変数はありませんが、書くとすれば。

&lt;ul&gt;&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1%&gt;&lt;/b&gt;: なにかをする&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;%HelpPageTestCase1(foobar)%&gt;&lt;/b&gt;: 別のなにかをする&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;サポートとバグ報告&lt;/h3&gt;

&lt;p&gt;さらなるサポートやバグ報告のために、次のフォーラムのスレッドを利用してください。
&lt;a href="http://forum.nucleuscms.org/viewtopic.php?t=&lt;トピックID&gt;"&gt;
http://forum.nucleuscms.org/viewtopic.php?t=&lt;トピックID&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;バージョン履歴&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;Version 0.1: 最初のテストケースバージョン&lt;/li&gt;
&lt;li&gt;Version 0.0: その前のバージョン ;-)&lt;/li&gt;&lt;/ul&gt;</code></pre>
</li>
<li>supportsFeature('HelpPage') で0より大きい数字を返すように設定します。
<pre><code>function supportsFeature($what) {
    switch($what) {
    case 'HelpPage':
        return 1;
      default:
        return 0;
    }
  }</code></pre>
</li>
</ol>

<h1>プラグイン依存チェック <a id="dependency" name="dependency" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>v3.2から、他のプラグインとの依存関係を宣言する新しいプラグインインターフェイスが追加されました。
他のプラグインの機能を必要とするプラグインに利用できます。特に依存関係が成立しなくて正しく機能しない状態を検知するときに便利です。</p>

<h2>この機能を利用するプラグインの書き方</h2>

<p>現実世界での例からはじめましょう。</p>

<p>NP_PageLinkList は NP_BlogWithOffset の機能を利用するため、利用者には NP_BlogWithOffset のインストール後に NP_PageLinkList をインストールさせたいとします。
NucleusはこのAPIによって、インストール前に依存関係を検知させる方法をプラグインに提供します。</p>

<p>このケースでは、NP_PageLinkList 側に NP_BlogWithOffset が必要だということを認識させるコードを埋め込みます。
プラグインがインストールされる際に、Nucleusコアは <code>getPluginDep()</code> というファンクションを呼び出します。
このファンクションは必要なプラグインのリストを返し、コアはインストール済みのプラグインをチェックして、もし依存関係に欠如があればインストールを拒否します。</p>

<p>必要なことは NP_PageLinkList にこのファンクションを追加する、ただそれだけです。</p>

<pre><code>function getPluginDep() {
     return array('NP_BlogWithOffset');
}</code></pre>

<p>このプラグイン依存チェックは、他のプラグインが依存しているプラグインがアンインストールされることも防ぎます。</p>

<h1>プラグインの多国語化<a name="internationalization" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>プラグインをより多くの人に使ってもらうために</h2>

<p>あなたと同じ言葉を話さない世界中の人達がプラグインをより使いやすくするために、プラグインを多国語化できます。
少し手間は増えますが、プラグインが出力する文章を翻訳するだけで可能です。
以下に Nucleus のコアで用意されている標準的な手順を記載します。
Andyさん、ありがとう！</p>

<ol>
	<li><strong>プラグインを作る</strong>

先ずはじめに、あなたが普段使っている言葉でプラグインを作ります。プラグインが安定して動作するようになってから、言語ファイルを作成することが推奨されます。</li>
	<li><strong>プラグインディレクトリを作る</strong>

作ったプラグインの名前が NP_AbcDef なら、プラグインディレクトリの名前は abcdef になります(必ず小文字を使用すること)。</li>
	<li><strong>言語ファイルを作る</strong>

プラグインディレクトリに言語ファイルを作成します。言語ファイルの名前は Nucleus コアが使用しているものと同じにします。例えば、英語なら english.php。日本語の UTF-8 なら japanese-utf8.phpになります(UTF がお勧めです。参考までに日本語の EUC の場合は japanese-euc.php になります)。</li>
	<li><strong>文を定義する</strong>

次のように言語ファイル内で分を定義します。

<pre class="example"><code>&lt;?php
define('_ABCDEF_MESSAGENAME',                  '実際のメッセージ');
  . . .
?&gt;</code></pre>

全ての文を定義する必要があります。定数は一回しか定義できないので、既に定義されているものと重複しないようにプラグインの名前をはじめにつけることが推奨されます(この例だと _ABCDEF)。</li>
	<li><strong>文の置き換え</strong>

全ての文を、言語ファイルで定義した定数と置き換えます</li>
	<li><strong>init() メソッドの編集</strong>

プラグイン内の init() メソッドを、次のように編集します(既に init() メソッドを定義している場合は init() メソッド内にコードを追記します)。

<pre class="example"><code>   function init() {
      // include language file for this plugin
      $language = preg_replace( '#\\\\|/#', '', getLanguageName());
      if (is_file($this-&gt;getDirectory().$language.'.php'))
         include_once($this-&gt;getDirectory().$language.'.php');
      else
         include_once($this-&gt;getDirectory().'english.php');
   }</code></pre>
このコードは Nucleus のコアで使用されているものと同一です。</li>

	<li><strong>言語ファイルの追加</strong>

｢英語｣が基本の言語になっていますので、｢英語｣の言語ファイルも追加することが望まれます。</li>
</ol>



<h1>スキン変数の出力の書式 <a name="skinvar-formatting" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<p>偉大なプラグインのいくつかは、様々なスキンや URL の生成において、必ずしもそのまま使用できるとはいえません。なぜなら、doSkinVar() メソッドによって出力されるものが、
ユーザーのニーズに十二分に合致するものであるとは言いがたいからです。Nucleus では、出力をここのユーザーによっておのおののニーズに沿ったものにするために、いくつかのツールを用意しています。</p>

<!--<h2>URLの出力</h2>-->

<p>各ブログ・カテゴリー・アイテム・メンバー、それから action.php や管理エリア、または各プラグインの管理エリアなどの URL を出力するために、Nucleus はコアの機能として
いくつかのファンクションとグローバル変数を用意しています。：</p>

<table summary="Nucleus の各ページへのリンクを生成するために便利な変数とファンクション">
	<caption>Nucleus の各ページへのリンクを生成するために便利な変数とファンクション</caption>
	<tr>
		<th>名前</th><th>種類</th><th>引数</th><th>説明</th>
	</tr>
	<tr>
		<td><code>$CONF['AdminURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus の管理領域への絶対 URL</td>
	</tr>
	<tr>
		<td><code>$CONF['PluginURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のプラグインディレクトリへの絶対 URL。<code>$CONF['PluginURL'].'pluginname/'</code> の様にして、プラグインの管理エリアへのリンク生成に使用する。</td>
	</tr>
	<tr>
		<td><code>$CONF['ActionURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus の action.php への絶対 URL。</td>
	</tr>
	<tr>
		<td><code>$CONF['MediaURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のメディアディレクトリへの絶対 URL。</td>
	</tr>
	<tr>
		<td><code>$CONF['SkinsURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のスキンディレクトリへの絶対 URL。</td>
	</tr>
	<tr>
		<td><code>$CONF['IndexURL']</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のメインディレクトリへの絶対 URL。</td>
	</tr>
	<tr>
		<td><code>$DIR_NUCLEUS</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のメインディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>$DIR_SKINS</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のスキンディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>$DIR_MEDIA</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のメディアディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>$DIR_PLUGINS</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のプラグインディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>$DIR_LANG</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus の言語ファイルディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>$DIR_LIBS</code></td>
		<td>グローバル変数</td>
		<td>なし</td>
		<td>Nucleus のコアディレクトリへのシステムルートからのフルパス。</td>
	</tr>
	<tr>
		<td><code>getAdminURL()</code></td>
		<td>PLUGIN クラス内メソッド</td>
		<td>なし</td>
		<td>プラグインの管理エリアディレクトリが存在すればその URL を返す(存在しない場合は無効)。</td>
	</tr>
	<tr>
		<td><code>getDirectory()</code></td>
		<td>PLUGIN クラス内メソッド</td>
		<td>なし</td>
		<td>プラグインの追加ファイルが格納されたサーバーのファイルシステムのパスを返します(存在しない場合は無効)。結果は".../nucleus/plugins/plugname/"のようになります。</td>
	</tr>
	<tr>
		<td><code>createItemLink($itemid, $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$itemid</code> 整数。リンクしたいアイテムの ID。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$itemid</code> に対応したアイテムへのリンクが生成されます。</td>
	</tr>
	<tr>
		<td><code>createMemberLink($memberid, $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$memberid</code> 整数。リンクしたい存在するメンバーの ID。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$memberid</code> に対応したメンバーへのリンクが生成されます。</td>
	</tr>
	<tr>
		<td><code>createCategoryLink($catid, $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$catid</code> 整数。リンクしたいカテゴリーの ID。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$catid</code> に対応したカテゴリーへのリンクが生成されます。</td>
	</tr>
	<tr>
		<td><code>createArchiveListLink($blogid = '', $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$blogid</code> 整数。リンクしたいアーカイブ一覧が存在ブログの ID。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$blogid</code> に対応したアーカイブ一覧へのリンクが生成されます。</td>
	</tr>
	<tr>
		<td><code>createArchiveLink($blogid, $archive, $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$blogid</code> 整数。リンクしたい月別アーカイブが存在するブログの ID。<br />
			<code>$archive</code> 文字列。アーカイブのパラメータとして、渡した｢日(または年、月)｣のものが存在するもの。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$blogid</code> に対応した月別アーカイブへのリンクが生成されます。</td>
	</tr>
	<tr>
		<td><code>createBlogidLink($blogid, $extra = '')</code></td>
		<td>グローバルファンクション</td>
		<td><code>$blogid</code> 整数。リンクしたいブログの ID。<br />
			<code>$extra</code> 連想配列。｢キー｣と｢値｣のペアが、URL の｢パラメータ｣と｢値｣に反映される。
		</td>
		<td>ユーザーによって選択されたスキームにより、 <code>$blogid</code> に対応したブログへのリンクが生成されます。</td>
	</tr>
</table>

<!--<h2>スキンへの出力にテンプレートを使う</h2>-->

<p>出力する文字列をテンプレートを使って整形できるようにしましょう。あなたが順不同のリストで出力したいと考えていたとしても、別のユーザーは同じデータを
記号で区切ったり、特別な形で出力したいと考えるかもしれません。Nucleus にはテンプレートデータを作ったり定義したりする2種類の方法があります。
次に上げるれいの両方において、<code>&lt;%foo%&gt;</code> と <code>&lt;%bar%&gt;</code> のふたつのテンプレート変数を使用します。</p>

<ol>
	<li><strong>プラグインのオプションを使う方法。</strong>この方法は v3.2 以降で使用でき、次のように <code>install()</code> メソッド
	に記述することによって簡単に作成できますが、アップグレードのためにプラグインを削除した時に、ユーザーは同時にカスタマイズした
	テンプレートを失ってしまうという大きなデメリットがあります。
	<pre class="example"><code>$this-&gt;createOption('my_template',
		'プラグインの出力のためのテンプレート',
		'textarea',
		'&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;&lt;/li&gt;');</code></pre>
	<code>doSkinVar()</code> メソッドで、<code>foo</code> と <code>bar</code> を次のように定義して、テンプレートを埋めます。
	<pre class="example"><code>$mytemplate = $this-&gt;getOption('my_template');
$couples = array(
			array(
				'foo'=&gt;'Ricky',
				'bar'=&gt;'Lucy'),
			array(
				'foo'=&gt;'Sid',
				'bar'=&gt;'Nancy'),
			array(
				'foo'=&gt;'Mickey',
				'bar'=&gt;'Minnie')
			);
foreach ($couples as $values) {
	echo TEMPLATE::fill($mytemplate,$values);
}</code></pre>
	これでプラグインのスキン変数 <code>&lt;%TemplateTest%&gt;</code> を書いたところに、次のように出力されます。
	<pre class="example"><code>&lt;li&gt;Ricky loves Lucy&lt;/li&gt;
&lt;li&gt;Sid loves Nancy&lt;/li&gt;
&lt;li&gt;Mickey loves Minnie&lt;/li&gt;</code></pre>
	</li>

	<li><strong>Nucleus コアのテンプレートシステムを使う方法。</strong>この方法は v3.4以降で使用できます。この方法の利点は、他のテンプレートと
	同じようにデータベースに格納され、配布用にテンプレートをエクスポートできるところにあります。この API を使用したプラグインのサンプルが、
	フォーラムの<a href="http://japan.nucleuscms.org/bb/viewtopic.php?p=24401#24401" title="Sample">新API「TemplateExtraFields」を使ったプラグインの見本</a>に
	(本家フォーラムのスレッドは <a href="http://forum.nucleuscms.org/viewtopic.php?p=87672#87672" title="Sample">Skin specific values for Plugins</a>)
	にあります。細かな点は本家フォーラムの <a href="http://forum.nucleuscms.org/viewtopic.php?p=87672#87672" title="Sample">Skin specific values for Plugins</a> スレッド
	を参照してください。ここでは要約のみ書いてあります。
	まず、<code>install()</code> メソッド中でプラグインオプションを作成し、ここでテンプレートのデフォルトの内容を定義します。
	<pre class="example"><code>$this-&gt;createOption('my_template',
		'Template used to format output of plugin.',
		'textarea',
		'&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;&lt;/li&gt;');</code></pre>
	次に割り込みをかけるイベントのリストに <code>TemplateExtraFields</code> を登録します。
	<pre class="example"><code>function getEventList() { return array('TemplateExtraFields'); }</code></pre>
	そして、<code>event_TemplateExtraFields</code> メソッドを作成します。
	<pre class="example"><code>function event_TemplateExtraFields(&amp;$data) {
    /* Add an element in the $data['fields'] array using your plugin name as the key
	and an associative array containing the field name and field label*/
    /* note that your field names should be lowercase and include the name
	of your template as shown below. This will ensure that all template field names are unique. */
    $data['fields']['NP_TemplateTest'] = array(
        'templatetest_body'=&gt;'TemplateTest Body'
    );
}</code></pre>
	最後に <code>doSkinVar()</code> メソッドで、テンプレートを埋めます。この時、スキン変数の引数に使用するテンプレート名が必要です。
	<pre class="example"><code>function doSkinVar($skinType,$template = '') {
	global $blog, $CONF, $manager,$member;

	$template =&amp; $manager-&gt;getTemplate($template);
	if (trim($template['templatetest_body']) == '')
		$template['templatetest_body'] = $this-&gt;getOption('my_template');

	$couples = array(
			array(
				'foo'=&gt;'Ricky',
				'bar'=&gt;'Lucy'),
			array(
				'foo'=&gt;'Sid',
				'bar'=&gt;'Nancy'),
			array(
				'foo'=&gt;'Mickey',
				'bar'=&gt;'Minnie')
			);
	foreach ($couples as $values) {
		echo TEMPLATE::fill($template['templatetest_body'],$values);
	}
}</code></pre>
	ユーザーは『テンプレート編集』画面で、「TemplateTest Body」フィールドに出力したい形式でテンプレートを編集します。
	例えば「default/index」テンプレートを使って、こんな風にテンプレートを編集します。
	<pre class="example"><code>&lt;li&gt;&lt;%foo%&gt; loves &lt;%bar%&gt;!!!&lt;/li&gt;</code></pre>
	そしてスキンに <code>&lt;%TemplateTest(default/index)%&gt;</code> と書くと、そこに
	<pre class="example"><code>&lt;li&gt;Ricky loves Lucy!!!&lt;/li&gt;
&lt;li&gt;Sid loves Nancy!!!&lt;/li&gt;
&lt;li&gt;Mickey loves Minnie!!!&lt;/li&gt;</code></pre>と表示されます。<br />
	</li>

	<li><strong>通常のテンプレートを使って書式化。</strong>この方法は v3.4 以降で、アイテムを出力するプラグインで使用できます。
	この方法にはコアのテンプレートシステムの既存の｢アイテム｣フィールドを使うというアドバンテージがあり、スキン変数の <code>&lt;%blog%&gt;</code>
	の様に使用します。スキン変数の引数として、一つ以上のアイテムの ID と使用するテンプレート名を、また、BLOG クラスの <code>readLogFromList()</code>
	メソッドを呼び出せることが条件です。テンプレート変数として使用したい場合は、<code>doTemplateVar()</code> メソッドで使用することもできます。
	例として <code>doSkinVar()</code> メソッドでこのテクニックを使う方法を示しておきます。
	4つのアイテムの ID を引数として受け取り、「default/index」テンプレートを使って出力します。
	<pre class="example"><code>function doSkinVar($skinType,$item1 = 0,$item2 = 0,$item3 = 0,$item4 = 0) {
	global $blog;
	$highlight = '';
	$template = 'default/index';
	$item_array = array($item1,$item2,$item3,$item4);
	$blog-&gt;readLogFromList($item_array, $template);
}</code></pre>

	</li>
</ol>


<h1>この他にも…… <a name="additional-reading" href="#top" class="toplink"><img src="../icon-up.gif" width="15" height="15" alt="back to top" /></a></h1>

<h2>役立つドキュメントがたくさん！</h2>

<p>このドキュメント以外にもあなたがプラグインを開発するにあたって、リンク先のページもきっと役立つことと思います。</p>
<ul>
<li><a href="http://wiki.nucleuscms.org/plugindev:index" title="Development Wiki">Development Wiki(公式サイト(英語))</a></li>
<li><a href="http://japan.nucleuscms.org/wiki/plugindev" title="Development Wiki">Nucleusプラグインの技術情報(日本公式サイト)</a></li>
<li><a href="sqltables.html" title="Database Tables">Nucleus - SQL テーブル構造</a></li>
<!-- <li><a href="" title=""></a></li> -->
</ul>

<!--
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
<pre class="example"><code></code></pre>
-->
</div>
</body>
</html>